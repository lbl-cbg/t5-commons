{"version":3,"file":"static/js/8735.0ddb8816.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-bed/esm/BedpeAdapter/BedpeAdapter.js"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { SimpleFeature } from '@jbrowse/core/util';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nexport function featureData(line, uniqueId, flip, names) {\n    const l = line.split('\\t');\n    const ref1 = l[flip ? 3 : 0];\n    const start1 = +l[flip ? 4 : 1];\n    const end1 = +l[flip ? 5 : 2];\n    const ref2 = l[!flip ? 3 : 0];\n    const start2 = +l[!flip ? 4 : 1];\n    const end2 = +l[!flip ? 5 : 2];\n    const name = l[6];\n    const score = +l[7];\n    const strand1 = parseStrand(l[8]);\n    const strand2 = parseStrand(l[9]);\n    const extra = l.slice(10);\n    const rest = names\n        ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n        : extra;\n    let ALT;\n    if (['DUP', 'TRA', 'INV', 'CNV', 'DEL'].includes(extra[0])) {\n        ALT = `<${extra[0]}>`;\n    }\n    return new SimpleFeature({\n        start: start1,\n        end: end1,\n        refName: ref1,\n        ...(ALT ? { ALT: [ALT] } : {}), // it's an array in VCF\n        strand: strand1,\n        name,\n        ...rest,\n        score,\n        uniqueId,\n        mate: { refName: ref2, start: start2, end: end2, strand: strand2 },\n    });\n}\nfunction parseStrand(strand) {\n    if (strand === '+') {\n        return 1;\n    }\n    else if (strand === '-') {\n        return -1;\n    }\n    else if (strand === '.') {\n        return 0;\n    }\n    else {\n        return undefined;\n    }\n}\nclass BedpeAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async loadDataP(opts = {}) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedpeLocation');\n        const buf = await openLocation(bedLoc, pm).readFile(opts);\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const headerLines = [];\n        let i = 0;\n        for (; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const feats1 = {};\n        const feats2 = {};\n        for (; i < lines.length; i++) {\n            const line = lines[i];\n            const cols = line.split('\\t');\n            const r1 = cols[0];\n            const r2 = cols[3];\n            if (!feats1[r1]) {\n                feats1[r1] = [];\n            }\n            if (!feats2[r2]) {\n                feats2[r2] = [];\n            }\n            feats1[r1].push(line);\n            feats2[r2].push(line);\n        }\n        const columnNames = this.getConf('columnNames');\n        return {\n            header,\n            feats1,\n            feats2,\n            columnNames,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.bedpeFeatures) {\n            this.bedpeFeatures = this.loadDataP(opts).catch(e => {\n                this.bedpeFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedpeFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { feats1, feats2 } = await this.loadData(opts);\n        return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])];\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureTreeP(refName) {\n        var _a, _b, _c, _d;\n        const { feats1, feats2 } = await this.loadData();\n        const names = await this.getNames();\n        const intervalTree = new IntervalTree();\n        const ret1 = (_b = (_a = feats1[refName]) === null || _a === void 0 ? void 0 : _a.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r1`, false, names))) !== null && _b !== void 0 ? _b : [];\n        const ret2 = (_d = (_c = feats2[refName]) === null || _c === void 0 ? void 0 : _c.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r2`, true, names))) !== null && _d !== void 0 ? _d : [];\n        for (const obj of [...ret1, ...ret2]) {\n            intervalTree.insert([obj.get('start'), obj.get('end')], obj);\n        }\n        return intervalTree;\n    }\n    async loadFeatureTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(e => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureTree(refName);\n            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => observer.next(f));\n            observer.complete();\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nBedpeAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default BedpeAdapter;\n"],"names":["featureData","line","uniqueId","flip","names","l","split","ref1","start1","end1","ref2","start2","end2","name","score","strand1","parseStrand","strand2","extra","slice","rest","Object","fromEntries","map","n","idx","ALT","includes","concat","SimpleFeature","start","end","refName","strand","mate","BedpeAdapter","BaseFeatureDataAdapter","constructor","super","arguments","this","intervalTrees","loadDataP","opts","length","undefined","pm","pluginManager","bedLoc","getConf","buf","openLocation","readFile","buffer","isGzip","unzip","Error","lines","TextDecoder","fatal","decode","filter","f","headerLines","i","startsWith","push","header","join","feats1","feats2","cols","r1","r2","columnNames","loadData","bedpeFeatures","catch","e","getRefNames","Set","keys","getHeader","getNames","defline","at","field","trim","loadFeatureTreeP","_a","_b","_c","_d","intervalTree","IntervalTree","ret1","id","ret2","obj","insert","get","loadFeatureTree","getFeatures","query","ObservableCreate","async","search","forEach","observer","next","complete","signal","freeResources","capabilities"],"sourceRoot":""}