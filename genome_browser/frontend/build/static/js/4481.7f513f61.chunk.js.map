{"version":3,"file":"static/js/4481.7f513f61.chunk.js","mappings":"2KAEO,SAASA,EAAcC,ICwGvB,SAAuBA,EAAMC,EAAIC,IACpCC,EAAAA,EAAAA,aAAYH,GAAMI,EAAAA,EAAAA,UAAQC,UACtB,UACUJ,GACV,CACA,MAAOK,IACCC,EAAAA,EAAAA,SAAQP,IACRA,EAAKQ,SAASF,EAEtB,IACDJ,GACP,CDlHIO,CAAcT,GAAMK,gBEFjBA,eAA2BL,GAE9B,MAAQU,aAAcC,IAAcC,EAAAA,EAAAA,oBAAmBZ,IACjD,WAAEa,IAAeC,EAAAA,EAAAA,YAAWd,GAC5Be,GAAOC,EAAAA,EAAAA,mBAAkBhB,GAC/B,IAAKe,EAAKE,aAAejB,EAAKkB,OAASlB,EAAKmB,eACxC,OAEJnB,EAAKoB,YAAW,GAChB,MAAMC,QAAaR,EAAWS,KAAKX,EAAW,kBAAmB,CAC7DA,YACAY,QAASR,EAAKS,aAAaC,cAC3BC,cAAe1B,EAAK0B,gBAExB1B,EAAK2B,YAAYN,GACjBrB,EAAKoB,YAAW,EACpB,CFbcQ,CAAY5B,EAAK,GACxB,CAAE6B,MAAO,KAChB,C","sources":["../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/afterAttach.js","../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/util.js","../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/fetchChains.js"],"sourcesContent":["import { createAutorun } from './util';\nimport { fetchChains } from './fetchChains';\nexport function doAfterAttach(self) {\n    createAutorun(self, async () => {\n        await fetchChains(self);\n    }, { delay: 1000 });\n}\n","import { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\nimport { addDisposer, isAlive } from 'mobx-state-tree';\nimport { autorun } from 'mobx';\n// get tag from BAM or CRAM feature, where CRAM uses feature.get('tags') and\n// BAM does not\nexport function getTag(feature, tag) {\n    const tags = feature.get('tags');\n    return tags !== undefined ? tags[tag] : feature.get(tag);\n}\n// use fallback alt tag, used in situations where upper case/lower case tags\n// exist e.g. Mm/MM for base modifications\nexport function getTagAlt(feature, tag, alt) {\n    var _a;\n    return (_a = getTag(feature, tag)) !== null && _a !== void 0 ? _a : getTag(feature, alt);\n}\n// orientation definitions from igv.js, see also\n// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\nexport const orientationTypes = {\n    fr: {\n        F1R2: 'LR',\n        F2R1: 'LR',\n        F1F2: 'LL',\n        F2F1: 'LL',\n        R1R2: 'RR',\n        R2R1: 'RR',\n        R1F2: 'RL',\n        R2F1: 'RL',\n    },\n    rf: {\n        R1F2: 'LR',\n        R2F1: 'LR',\n        R1R2: 'LL',\n        R2R1: 'LL',\n        F1F2: 'RR',\n        F2F1: 'RR',\n        F1R2: 'RL',\n        F2R1: 'RL',\n    },\n    ff: {\n        F2F1: 'LR',\n        R1R2: 'LR',\n        F2R1: 'LL',\n        R1F2: 'LL',\n        R2F1: 'RR',\n        F1R2: 'RR',\n        R2R1: 'RL',\n        F1F2: 'RL',\n    },\n};\nexport const pairMap = {\n    LR: 'color_pair_lr',\n    LL: 'color_pair_ll',\n    RR: 'color_pair_rr',\n    RL: 'color_pair_rl',\n};\nexport function getColorWGBS(strand, base) {\n    if (strand === 1) {\n        if (base === 'C') {\n            return '#f00';\n        }\n        if (base === 'T') {\n            return '#00f';\n        }\n    }\n    else if (strand === -1) {\n        if (base === 'G') {\n            return '#f00';\n        }\n        if (base === 'A') {\n            return '#00f';\n        }\n    }\n    return '#888';\n}\n// fetches region sequence augmenting by +/- 1bp for CpG on either side of\n// requested region\nexport async function fetchSequence(region, adapter) {\n    var _a;\n    const { start, end, originalRefName, refName } = region;\n    const feats = await firstValueFrom(adapter\n        .getFeatures({\n        ...region,\n        refName: originalRefName || refName,\n        end: end + 1,\n        start: Math.max(0, start - 1),\n    })\n        .pipe(toArray()));\n    return (_a = feats[0]) === null || _a === void 0 ? void 0 : _a.get('seq');\n}\n// has to check underlying C-G (aka CpG) on the reference sequence\nexport function shouldFetchReferenceSequence(type) {\n    return type === 'methylation';\n}\n// adapted from IGV\n// https://github.com/igvteam/igv/blob/e803e3af2d8c9ea049961dfd4628146bdde9a574/src/main/java/org/broad/igv/sam/mods/BaseModificationColors.java#L27\nexport const modificationColors = {\n    m: 'rgb(255,0,0)',\n    h: 'rgb(11, 132, 165)',\n    o: 'rgb(111, 78, 129)',\n    f: 'rgb(246, 200, 95)',\n    c: 'rgb(157, 216, 102)',\n    g: 'rgb(255, 160, 86)',\n    e: 'rgb(141, 221, 208)',\n    b: 'rgb(202, 71, 47)',\n};\nexport function createAutorun(self, cb, opts) {\n    addDisposer(self, autorun(async () => {\n        try {\n            await cb();\n        }\n        catch (e) {\n            if (isAlive(self)) {\n                self.setError(e);\n            }\n        }\n    }, opts));\n}\nexport function randomColor() {\n    return `hsl(${Math.random() * 200}, 50%, 50%)`;\n}\n","import { getContainingTrack, getContainingView, getSession, } from '@jbrowse/core/util';\nexport async function fetchChains(self) {\n    // @ts-expect-error\n    const { rpcSessionId: sessionId } = getContainingTrack(self);\n    const { rpcManager } = getSession(self);\n    const view = getContainingView(self);\n    if (!view.initialized || self.error || self.regionTooLarge) {\n        return;\n    }\n    self.setLoading(true);\n    const ret = (await rpcManager.call(sessionId, 'CoreGetFeatures', {\n        sessionId,\n        regions: view.staticBlocks.contentBlocks,\n        adapterConfig: self.adapterConfig,\n    }));\n    self.setFeatures(ret);\n    self.setLoading(false);\n}\n"],"names":["doAfterAttach","self","cb","opts","addDisposer","autorun","async","e","isAlive","setError","createAutorun","rpcSessionId","sessionId","getContainingTrack","rpcManager","getSession","view","getContainingView","initialized","error","regionTooLarge","setLoading","ret","call","regions","staticBlocks","contentBlocks","adapterConfig","setFeatures","fetchChains","delay"],"sourceRoot":""}