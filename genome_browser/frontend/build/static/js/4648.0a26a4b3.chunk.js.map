{"version":3,"file":"static/js/4648.0a26a4b3.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-gff3/esm/Gff3TabixAdapter/Gff3TabixAdapter.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { doesIntersect2 } from '@jbrowse/core/util/range';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { TabixIndexedFile } from '@gmod/tabix';\nimport gff from '@gmod/gff';\nimport { readConfObject, } from '@jbrowse/core/configuration';\nexport default class extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const gffGzLocation = readConfObject(config, 'gffGzLocation');\n        const indexType = readConfObject(config, ['index', 'indexType']);\n        const location = readConfObject(config, ['index', 'location']);\n        const dontRedispatch = readConfObject(config, 'dontRedispatch');\n        this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region'];\n        this.gff = new TabixIndexedFile({\n            filehandle: openLocation(gffGzLocation, this.pluginManager),\n            csiFilehandle: indexType === 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: indexType !== 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            renameRefSeqs: (n) => n,\n        });\n    }\n    async getRefNames(opts = {}) {\n        return this.gff.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        return this.gff.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const metadata = await this.gff.getMetadata();\n            await this.getFeaturesHelper(query, opts, metadata, observer, true);\n        }, opts.signal);\n    }\n    async getFeaturesHelper(query, opts = {}, metadata, observer, allowRedispatch, originalQuery = query) {\n        try {\n            const lines = [];\n            await this.gff.getLines(query.refName, query.start, query.end, (line, fileOffset) => {\n                lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset));\n            });\n            if (allowRedispatch && lines.length) {\n                let minStart = Infinity;\n                let maxEnd = -Infinity;\n                lines.forEach(line => {\n                    const featureType = line.fields[2];\n                    // only expand redispatch range if feature is not a \"dontRedispatch\" type\n                    // skips large regions like chromosome,region\n                    if (!this.dontRedispatch.includes(featureType)) {\n                        const start = line.start - 1; // gff is 1-based\n                        if (start < minStart) {\n                            minStart = start;\n                        }\n                        if (line.end > maxEnd) {\n                            maxEnd = line.end;\n                        }\n                    }\n                });\n                if (maxEnd > query.end || minStart < query.start) {\n                    // make a new feature callback to only return top-level features\n                    // in the original query range\n                    await this.getFeaturesHelper({ ...query, start: minStart, end: maxEnd }, opts, metadata, observer, false, query);\n                    return;\n                }\n            }\n            const gff3 = lines\n                .map((lineRecord) => {\n                if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                    if (!lineRecord.fields[8].includes('_lineHash')) {\n                        lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`;\n                    }\n                }\n                else {\n                    lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`;\n                }\n                return lineRecord.fields.join('\\t');\n            })\n                .join('\\n');\n            const features = gff.parseStringSync(gff3, {\n                parseFeatures: true,\n                parseComments: false,\n                parseDirectives: false,\n                parseSequences: false,\n                disableDerivesFromReferences: true,\n            });\n            features.forEach(featureLocs => this.formatFeatures(featureLocs).forEach(f => {\n                if (doesIntersect2(f.get('start'), f.get('end'), originalQuery.start, originalQuery.end)) {\n                    observer.next(f);\n                }\n            }));\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t');\n        // note: index column numbers are 1-based\n        return {\n            start: +fields[columnNumbers.start - 1],\n            end: +fields[columnNumbers.end - 1],\n            lineHash: fileOffset,\n            fields,\n        };\n    }\n    formatFeatures(featureLocs) {\n        return featureLocs.map(featureLoc => new SimpleFeature({\n            data: this.featureData(featureLoc),\n            id: `${this.id}-offset-${featureLoc.attributes._lineHash[0]}`,\n        }));\n    }\n    featureData(data) {\n        const f = { ...data };\n        f.start -= 1; // convert to interbase\n        if (data.strand === '+') {\n            f.strand = 1;\n        }\n        else if (data.strand === '-') {\n            f.strand = -1;\n        }\n        else if (data.strand === '.') {\n            f.strand = 0;\n        }\n        else {\n            f.strand = undefined;\n        }\n        f.phase = Number(data.phase);\n        f.refName = data.seq_id;\n        if (data.score === null) {\n            delete f.score;\n        }\n        if (data.phase === null) {\n            delete f.score;\n        }\n        const defaultFields = new Set([\n            'start',\n            'end',\n            'seq_id',\n            'score',\n            'type',\n            'source',\n            'phase',\n            'strand',\n        ]);\n        const dataAttributes = data.attributes || {};\n        for (const a of Object.keys(dataAttributes)) {\n            let b = a.toLowerCase();\n            if (defaultFields.has(b)) {\n                // add \"suffix\" to tag name if it already exists\n                // reproduces behavior of NCList\n                b += '2';\n            }\n            if (dataAttributes[a] !== null) {\n                let attr = dataAttributes[a];\n                if (Array.isArray(attr) && attr.length === 1) {\n                    ;\n                    [attr] = attr;\n                }\n                f[b] = attr;\n            }\n        }\n        f.refName = f.seq_id;\n        // the SimpleFeature constructor takes care of recursively inflating subfeatures\n        if (data.child_features && data.child_features.length > 0) {\n            f.subfeatures = data.child_features.flatMap(childLocs => childLocs.map(childLoc => this.featureData(childLoc)));\n        }\n        delete f.child_features;\n        delete f.data;\n        // delete f.derived_features\n        delete f._linehash;\n        delete f.attributes;\n        delete f.seq_id;\n        return f;\n    }\n    freeResources( /* { region } */) { }\n}\n"],"names":["BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","gffGzLocation","readConfObject","indexType","location","dontRedispatch","this","gff","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","renameRefSeqs","n","getRefNames","opts","arguments","length","getReferenceSequenceNames","getHeader","getFeatures","query","ObservableCreate","async","metadata","getMetadata","getFeaturesHelper","observer","signal","allowRedispatch","originalQuery","lines","getLines","refName","start","end","line","fileOffset","push","parseLine","columnNumbers","minStart","Infinity","maxEnd","forEach","featureType","fields","includes","gff3","map","lineRecord","concat","lineHash","join","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","featureLocs","formatFeatures","f","doesIntersect2","get","next","complete","e","error","split","featureLoc","SimpleFeature","data","featureData","id","attributes","_lineHash","strand","phase","Number","seq_id","score","defaultFields","Set","dataAttributes","a","Object","keys","b","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc","_linehash","freeResources"],"sourceRoot":""}