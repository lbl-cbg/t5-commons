{"version":3,"file":"static/js/9621.158283ee.chunk.js","mappings":"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","sources":["../node_modules/@flatten-js/interval-tree/dist/main.mjs"],"sourcesContent":["/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback(value,key) - function to be called for each tree item\n     */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    /**\n     * @param {Interval} interval - optional if the iterator is intended to start from the beginning\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Iterator}\n     */\n    *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let node;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node(interval));\n        } else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            yield outputMapperFn(node.item.value, node.item.key);\n            node = this.tree_successor(node);\n        }\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    tree_search_nearest_forward(node, search_node) {\n        let best;\n        let curr = node;\n        while (curr && curr != this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                } else {\n                    curr = curr.right;\n                }\n            } else {\n                if (!best || curr.less_than(best)) best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport { Interval, Node, IntervalTree as default };\n"],"names":["Interval","constructor","low","high","this","clone","max","less_than","other_interval","equal_to","intersect","not_intersect","merge","undefined","Math","min","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","Node","key","arguments","length","value","left","right","parent","color","item","Array","Number","isNaN","isNil","_value_less_than","other_node","_value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","IntervalTree","root","nil_node","size","count","tree_walk","keys","res","node","push","values","items","isEmpty","clear","insert","insert_node","tree_insert","recalc_max","exist","tree_search","remove","delete_node","tree_delete","search","interval","outputMapperFn","resp_nodes","tree_search_interval","map","intersect_any","tree_find_any_interval","forEach","visitor","callback","tree","iterate","_this","tree_search_nearest_forward","local_minimum","tree_successor","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","delete_fixup","brother_node","best","curr","found","node_min","local_maximum","node_max","node_successor","x","y","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight","Error"],"sourceRoot":""}