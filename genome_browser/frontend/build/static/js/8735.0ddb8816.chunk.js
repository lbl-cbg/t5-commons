"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[8735],{88735:(e,t,a)=>{a.r(t),a.d(t,{default:()=>h,featureData:()=>c});var n=a(48591),s=a(50472),r=a(10718),i=a(91775),o=a(19621),l=a(43050);function c(e,t,a,n){const s=e.split("\t"),r=s[a?3:0],o=+s[a?4:1],l=+s[a?5:2],c=s[a?0:3],u=+s[a?1:4],h=+s[a?2:5],f=s[6],p=+s[7],m=d(s[8]),v=d(s[9]),g=s.slice(10),w=n?Object.fromEntries(n.slice(10).map(((e,t)=>[e,g[t]]))):g;let b;return["DUP","TRA","INV","CNV","DEL"].includes(g[0])&&(b="<".concat(g[0],">")),new i.SimpleFeature({start:o,end:l,refName:r,...b?{ALT:[b]}:{},strand:m,name:f,...w,score:p,uniqueId:t,mate:{refName:c,start:u,end:h,strand:v}})}function d(e){return"+"===e?1:"-"===e?-1:"."===e?0:void 0}class u extends n.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=this.pluginManager,a=this.getConf("bedpeLocation"),n=await(0,s.openLocation)(a,t).readFile(e),r=function(e){return 31===e[0]&&139===e[1]&&8===e[2]}(n)?await(0,l.unzip)(n):n;if(r.length>536870888)throw new Error("Data exceeds maximum string length (512MB)");const i=new TextDecoder("utf8",{fatal:!0}).decode(r).split(/\n|\r\n|\r/).filter((e=>!!e)),o=[];let c=0;for(;c<i.length&&i[c].startsWith("#");c++)o.push(i[c]);const d=o.join("\n"),u={},h={};for(;c<i.length;c++){const e=i[c],t=e.split("\t"),a=t[0],n=t[3];u[a]||(u[a]=[]),h[n]||(h[n]=[]),u[a].push(e),h[n].push(e)}return{header:d,feats1:u,feats2:h,columnNames:this.getConf("columnNames")}}async loadData(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.bedpeFeatures||(this.bedpeFeatures=this.loadDataP(e).catch((e=>{throw this.bedpeFeatures=void 0,e}))),this.bedpeFeatures}async getRefNames(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{feats1:t,feats2:a}=await this.loadData(e);return[...new Set([...Object.keys(t),...Object.keys(a)])]}async getHeader(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{header:t}=await this.loadData(e);return t}async getNames(){const{header:e,columnNames:t}=await this.loadData();if(t.length)return t;const a=e.split(/\n|\r\n|\r/).filter((e=>!!e)).at(-1);return(null===a||void 0===a?void 0:a.includes("\t"))?a.slice(1).split("\t").map((e=>e.trim())):void 0}async loadFeatureTreeP(e){var t,a,n,s;const{feats1:r,feats2:i}=await this.loadData(),l=await this.getNames(),d=new o.Ay,u=null!==(a=null===(t=r[e])||void 0===t?void 0:t.map(((t,a)=>c(t,"".concat(this.id,"-").concat(e,"-").concat(a,"-r1"),!1,l))))&&void 0!==a?a:[],h=null!==(s=null===(n=i[e])||void 0===n?void 0:n.map(((t,a)=>c(t,"".concat(this.id,"-").concat(e,"-").concat(a,"-r2"),!0,l))))&&void 0!==s?s:[];for(const o of[...u,...h])d.insert([o.get("start"),o.get("end")],o);return d}async loadFeatureTree(e){return this.intervalTrees[e]||(this.intervalTrees[e]=this.loadFeatureTreeP(e).catch((t=>{throw this.intervalTrees[e]=void 0,t}))),this.intervalTrees[e]}getFeatures(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,r.ObservableCreate)((async t=>{const{start:a,end:n,refName:s}=e,r=await this.loadFeatureTree(s);null===r||void 0===r||r.search([a,n]).forEach((e=>t.next(e))),t.complete()}),t.signal)}freeResources(){}}u.capabilities=["getFeatures","getRefNames"];const h=u}}]);
//# sourceMappingURL=8735.0ddb8816.chunk.js.map