{"version":3,"file":"static/js/1078.b8fafabd.chunk.js","mappings":"oNA2BA,MAAMA,UAAmBC,EAAAA,uBACrB,eAAMC,GACF,MAAM,OAAEC,SAAiBC,KAAKC,QAC9B,OAAOF,CACX,CACA,iBAAMG,GACF,MAAM,OAAEH,SAAiBC,KAAKC,QAE9B,OADe,IAAIE,EAAAA,EAAI,CAAEJ,OAAQA,IACnBG,aAClB,CAEA,YAAME,GACF,MAAMC,EAAKL,KAAKM,cACVC,QAAYC,EAAAA,EAAAA,cAAaR,KAAKS,QAAQ,eAAgBJ,GAAIK,WAC1DC,EAjBd,SAAgBJ,GACZ,OAAkB,KAAXA,EAAI,IAAwB,MAAXA,EAAI,IAAyB,IAAXA,EAAI,EAClD,CAeuBK,CAAOL,SAAaM,EAAAA,EAAAA,OAAMN,GAAOA,EAEhD,GAAII,EAAOG,OAAS,UAChB,MAAM,IAAIC,MAAM,8CAEpB,MAAMC,GAAM,IAAIC,aAAcC,OAAOP,IAC/B,OAAEZ,EAAM,MAAEoB,GAvCPC,KACb,MAAMrB,EAAS,GACTsB,EAAO,GAYb,OAXAD,EAAEE,MAAM,cACHC,KAAIH,GAAKA,EAAEI,SACXC,QAAOL,KAAOA,IACdM,SAAQC,IACLA,EAAKC,WAAW,KAChB7B,EAAO8B,KAAKF,GAEPA,GACLN,EAAKQ,KAAKF,EACd,IAEG,CAAE5B,OAAQA,EAAO+B,KAAK,MAAOX,MAAOE,EAAM,EAyBnBU,CAAQf,GAC5BgB,EAAe,CAAC,EAChBC,EAAS,IAAI9B,EAAAA,EAAI,CAAEJ,WACzB,IAAImC,EAAM,EACV,IAAK,MAAMP,KAAQR,EAAO,CACtB,MAAMC,EAAI,IAAIe,EAAAA,EAAW,CACrBC,QAASH,EAAOI,UAAUV,GAC1BM,SACAK,GAAI,GAAFC,OAAKvC,KAAKsC,GAAE,KAAAC,OAAIL,OAEhBM,EAAMpB,EAAEqB,IAAI,WACbT,EAAaQ,KACdR,EAAaQ,GAAO,IAAIE,EAAAA,IAE5BV,EAAaQ,GAAKG,OAAO,CAACvB,EAAEqB,IAAI,SAAUrB,EAAEqB,IAAI,QAASrB,EAC7D,CACA,MAAO,CAAErB,SAAQiC,eACrB,CACA,WAAM/B,GAOF,OANKD,KAAK4C,cACN5C,KAAK4C,YAAc5C,KAAKI,SAASyC,OAAMC,IAEnC,MADA9C,KAAK4C,iBAAcG,EACbD,CAAC,KAGR9C,KAAK4C,WAChB,CACA,iBAAMI,GACF,MAAM,aAAEhB,SAAuBhC,KAAKC,QACpC,OAAOgD,OAAOC,KAAKlB,EACvB,CACAmB,WAAAA,CAAYC,GAAmB,IAAXC,EAAIC,UAAAxC,OAAA,QAAAiC,IAAAO,UAAA,GAAAA,UAAA,GAAG,CAAC,EACxB,OAAOC,EAAAA,EAAAA,mBAAiBC,UACpB,IAAIC,EACJ,IACI,MAAM,MAAEC,EAAK,IAAEC,EAAG,QAAEC,GAAYR,GAC1B,aAAEpB,SAAuBhC,KAAKC,QACH,QAAhCwD,EAAKzB,EAAa4B,UAA6B,IAAPH,GAAyBA,EAAGI,OAAO,CAACH,EAAOC,IAAMjC,SAASN,IAC/F0C,EAASC,KAAK3C,EAAE,IAEpB0C,EAASE,UACb,CACA,MAAOlB,GACHgB,EAASG,MAAMnB,EACnB,IACDO,EAAKa,OACZ,CACAC,aAAAA,GAAkB,EAEtBvE,EAAWwE,aAAe,CAAC,cAAe,eAC1C,S","sources":["../node_modules/@jbrowse/plugin-variants/esm/VcfAdapter/VcfAdapter.js"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport VCF from '@gmod/vcf';\n// local\nimport VcfFeature from '../VcfFeature';\nconst readVcf = (f) => {\n    const header = [];\n    const rest = [];\n    f.split(/\\n|\\r\\n|\\r/)\n        .map(f => f.trim())\n        .filter(f => !!f)\n        .forEach(line => {\n        if (line.startsWith('#')) {\n            header.push(line);\n        }\n        else if (line) {\n            rest.push(line);\n        }\n    });\n    return { header: header.join('\\n'), lines: rest };\n};\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nclass VcfAdapter extends BaseFeatureDataAdapter {\n    async getHeader() {\n        const { header } = await this.setup();\n        return header;\n    }\n    async getMetadata() {\n        const { header } = await this.setup();\n        const parser = new VCF({ header: header });\n        return parser.getMetadata();\n    }\n    // converts lines into an interval tree\n    async setupP() {\n        const pm = this.pluginManager;\n        const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile();\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const str = new TextDecoder().decode(buffer);\n        const { header, lines } = readVcf(str);\n        const intervalTree = {};\n        const parser = new VCF({ header });\n        let idx = 0;\n        for (const line of lines) {\n            const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${idx++}`,\n            });\n            const key = f.get('refName');\n            if (!intervalTree[key]) {\n                intervalTree[key] = new IntervalTree();\n            }\n            intervalTree[key].insert([f.get('start'), f.get('end')], f);\n        }\n        return { header, intervalTree };\n    }\n    async setup() {\n        if (!this.vcfFeatures) {\n            this.vcfFeatures = this.setupP().catch(e => {\n                this.vcfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.vcfFeatures;\n    }\n    async getRefNames(_ = {}) {\n        const { intervalTree } = await this.setup();\n        return Object.keys(intervalTree);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = region;\n                const { intervalTree } = await this.setup();\n                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach((f) => {\n                    observer.next(f);\n                });\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nVcfAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default VcfAdapter;\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","getHeader","header","this","setup","getMetadata","VCF","setupP","pm","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","length","Error","str","TextDecoder","decode","lines","f","rest","split","map","trim","filter","forEach","line","startsWith","push","join","readVcf","intervalTree","parser","idx","VcfFeature","variant","parseLine","id","concat","key","get","IntervalTree","insert","vcfFeatures","catch","e","undefined","getRefNames","Object","keys","getFeatures","region","opts","arguments","ObservableCreate","async","_a","start","end","refName","search","observer","next","complete","error","signal","freeResources","capabilities"],"sourceRoot":""}