{"version":3,"file":"static/js/9200.7d5d1c5c.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/generateCoverageBins.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/SNPCoverageAdapter.js"],"sourcesContent":["import { getTag, getTagAlt, shouldFetchReferenceSequence } from '../util';\nimport { parseCigar, getNextRefPos, getModificationPositions, getMethBins, } from '../MismatchParser';\nimport { doesIntersect2 } from '@jbrowse/core/util';\nfunction mismatchLen(mismatch) {\n    return !isInterbase(mismatch.type) ? mismatch.length : 1;\n}\nfunction isInterbase(type) {\n    return type === 'softclip' || type === 'hardclip' || type === 'insertion';\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction inc(bin, strand, type, field) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            total: 0,\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.total++;\n    thisBin[strand]++;\n}\nexport default async function generateCoverageBins(features, region, opts, fetchSequence) {\n    var _a, _b, _c;\n    const { colorBy } = opts;\n    const extendedRegion = {\n        ...region,\n        start: Math.max(0, region.start - 1),\n        end: region.end + 1,\n    };\n    const binMax = Math.ceil(extendedRegion.end - extendedRegion.start);\n    const skipmap = {};\n    const regionSequence = features.length && shouldFetchReferenceSequence((_a = opts.colorBy) === null || _a === void 0 ? void 0 : _a.type)\n        ? await fetchSequence(region)\n        : undefined;\n    const bins = [];\n    for (const feature of features) {\n        const fstart = feature.get('start');\n        const fend = feature.get('end');\n        const fstrand = feature.get('strand');\n        const mismatches = feature.get('mismatches') || [];\n        for (let j = fstart; j < fend + 1; j++) {\n            const i = j - region.start;\n            if (i >= 0 && i < binMax) {\n                if (bins[i] === undefined) {\n                    bins[i] = {\n                        total: 0,\n                        all: 0,\n                        ref: 0,\n                        '-1': 0,\n                        '0': 0,\n                        '1': 0,\n                        lowqual: {},\n                        cov: {},\n                        delskips: {},\n                        noncov: {},\n                    };\n                }\n                if (j !== fend) {\n                    bins[i].total++;\n                    bins[i].all++;\n                    bins[i].ref++;\n                    bins[i][fstrand]++;\n                }\n            }\n        }\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {\n            const seq = feature.get('seq');\n            const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n            const ops = parseCigar(feature.get('CIGAR'));\n            const fend = feature.get('end');\n            if (seq) {\n                const modifications = getModificationPositions(mm, seq, fstrand);\n                for (const { type, positions } of modifications) {\n                    const mod = `mod_${type}`;\n                    for (const pos of getNextRefPos(ops, positions)) {\n                        const epos = pos + fstart - region.start;\n                        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n                            if (bins[epos] === undefined) {\n                                bins[epos] = {\n                                    total: 0,\n                                    all: 0,\n                                    ref: 0,\n                                    '-1': 0,\n                                    '0': 0,\n                                    '1': 0,\n                                    lowqual: {},\n                                    cov: {},\n                                    delskips: {},\n                                    noncov: {},\n                                };\n                            }\n                            const bin = bins[epos];\n                            if (bin) {\n                                inc(bin, fstrand, 'cov', mod);\n                            }\n                            else {\n                                console.warn('Undefined position in modifications snpcoverage encountered');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {\n            if (!regionSequence) {\n                throw new Error('no region sequence detected, need sequenceAdapter configuration');\n            }\n            const seq = feature.get('seq');\n            if (!seq) {\n                continue;\n            }\n            const { methBins, methProbs } = getMethBins(feature);\n            const dels = mismatches.filter(f => f.type === 'deletion');\n            // methylation based coloring takes into account both reference sequence\n            // CpG detection and reads\n            for (let i = 0; i < fend - fstart; i++) {\n                const j = i + fstart;\n                const l1 = (_b = regionSequence[j - region.start + 1]) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n                const l2 = (_c = regionSequence[j - region.start + 2]) === null || _c === void 0 ? void 0 : _c.toLowerCase();\n                if (l1 === 'c' && l2 === 'g') {\n                    const bin0 = bins[j - region.start];\n                    const bin1 = bins[j - region.start + 1];\n                    const b0 = methBins[i];\n                    const b1 = methBins[i + 1];\n                    const p0 = methProbs[i];\n                    const p1 = methProbs[i + 1];\n                    // color\n                    if ((b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n                        (b1 && (p1 !== undefined ? p1 > 0.5 : true))) {\n                        if (bin0) {\n                            inc(bin0, fstrand, 'cov', 'meth');\n                            bin0.ref--;\n                            bin0[fstrand]--;\n                        }\n                        if (bin1) {\n                            inc(bin1, fstrand, 'cov', 'meth');\n                            bin1.ref--;\n                            bin1[fstrand]--;\n                        }\n                    }\n                    else {\n                        if (bin0) {\n                            if (!(dels === null || dels === void 0 ? void 0 : dels.some(d => doesIntersect2(j, j + 1, d.start + fstart, d.start + fstart + d.length)))) {\n                                inc(bin0, fstrand, 'cov', 'unmeth');\n                                bin0.ref--;\n                                bin0[fstrand];\n                            }\n                        }\n                        if (bin1) {\n                            if (!(dels === null || dels === void 0 ? void 0 : dels.some(d => doesIntersect2(j + 1, j + 2, d.start + fstart, d.start + fstart + d.length)))) {\n                                inc(bin1, fstrand, 'cov', 'unmeth');\n                                bin1.ref--;\n                                bin1[fstrand]--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // normal SNP based coloring\n        const colorSNPs = (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'modifications' && (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'methylation';\n        for (const mismatch of mismatches) {\n            const mstart = fstart + mismatch.start;\n            const mlen = mismatchLen(mismatch);\n            const mend = mstart + mlen;\n            for (let j = mstart; j < mstart + mlen; j++) {\n                const epos = j - region.start;\n                if (epos >= 0 && epos < bins.length) {\n                    const bin = bins[epos];\n                    const { base, type } = mismatch;\n                    const interbase = isInterbase(type);\n                    if (!interbase) {\n                        bin.ref--;\n                        bin[fstrand]--;\n                    }\n                    else {\n                        inc(bin, fstrand, 'noncov', type);\n                    }\n                    if (type === 'deletion' || type === 'skip') {\n                        inc(bin, fstrand, 'delskips', type);\n                        bin.total--;\n                    }\n                    else if (!interbase && colorSNPs) {\n                        inc(bin, fstrand, 'cov', base);\n                        bin.refbase = mismatch.altbase;\n                    }\n                }\n            }\n            if (mismatch.type === 'skip') {\n                const hash = `${mstart}_${mend}_${fstrand}`;\n                if (skipmap[hash] === undefined) {\n                    skipmap[hash] = {\n                        feature: feature,\n                        start: mstart,\n                        end: mend,\n                        strand: fstrand,\n                        xs: getTag(feature, 'XS') || getTag(feature, 'TS'),\n                        score: 0,\n                    };\n                }\n                skipmap[hash].score++;\n            }\n        }\n    }\n    return { bins, skipmap };\n}\n","import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\n// locals\nimport generateCoverageBins from './generateCoverageBins';\nimport { fetchSequence } from '../util';\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n    async configure() {\n        var _a, _b;\n        const subadapterConfig = this.getConf('subadapter');\n        const sequenceConf = subadapterConfig.sequenceAdapter;\n        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));\n        const sequenceAdapter = sequenceConf\n            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))\n            : undefined;\n        if (!dataAdapter) {\n            throw new Error('Failed to get subadapter');\n        }\n        return {\n            subadapter: dataAdapter.dataAdapter,\n            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,\n        };\n    }\n    async fetchSequence(region) {\n        const { sequenceAdapter } = await this.configure();\n        if (!sequenceAdapter) {\n            return undefined;\n        }\n        return fetchSequence(region, sequenceAdapter);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { subadapter } = await this.configure();\n            const feats = await firstValueFrom(subadapter.getFeatures(region, opts).pipe(toArray()));\n            const { bins, skipmap } = await generateCoverageBins(feats, region, opts, arg => this.fetchSequence(arg));\n            bins.forEach((bin, index) => {\n                const start = region.start + index;\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${start}`,\n                    data: {\n                        score: bin.total,\n                        snpinfo: bin,\n                        start,\n                        end: start + 1,\n                        refName: region.refName,\n                    },\n                }));\n            });\n            // make fake features from the coverage\n            Object.entries(skipmap).forEach(([key, skip]) => {\n                observer.next(new SimpleFeature({\n                    id: key,\n                    data: {\n                        type: 'skip',\n                        start: skip.start,\n                        end: skip.end,\n                        strand: skip.strand,\n                        score: skip.score,\n                        xs: skip.xs,\n                    },\n                }));\n            });\n            observer.complete();\n        }, opts.signal);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { subadapter } = await this.configure();\n        return subadapter.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    async getRefNames(opts = {}) {\n        const { subadapter } = await this.configure();\n        return subadapter.getRefNames(opts);\n    }\n    freeResources( /* { region } */) { }\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","undefined","total","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","_a","_b","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","call","Error","subadapter","fetchSequence","region","getFeatures","opts","arguments","ObservableCreate","async","feats","firstValueFrom","pipe","toArray","bins","skipmap","features","_c","colorBy","extendedRegion","start","Math","max","end","binMax","ceil","regionSequence","shouldFetchReferenceSequence","feature","fstart","get","fend","fstrand","mismatches","j","i","all","ref","lowqual","cov","delskips","noncov","seq","mm","getTagAlt","ops","parseCigar","modifications","getModificationPositions","positions","mod","concat","pos","getNextRefPos","epos","console","warn","methBins","methProbs","getMethBins","dels","filter","f","l1","toLowerCase","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","colorSNPs","mstart","mlen","mend","base","interbase","refbase","altbase","hash","xs","getTag","score","generateCoverageBins","arg","forEach","index","observer","next","SimpleFeature","id","data","snpinfo","refName","Object","entries","_ref","key","skip","complete","signal","getMultiRegionFeatureDensityStats","regions","getRefNames","freeResources"],"sourceRoot":""}