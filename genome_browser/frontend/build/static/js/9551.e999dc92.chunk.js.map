{"version":3,"file":"static/js/9551.e999dc92.chunk.js","mappings":"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","sources":["../node_modules/@gmod/indexedfasta/src/indexedFasta.ts","../node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts","../node_modules/@jbrowse/plugin-sequence/esm/IndexedFastaAdapter/IndexedFastaAdapter.js"],"sourcesContent":["import { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts?: BaseOpts) {\n  const text = await fai.readFile(opts)\n  if (!(text && text.length)) {\n    throw new Error('No data read from FASTA index (FAI) file')\n  }\n\n  let idCounter = 0\n  let currSeq: { name: string; id: number } | undefined\n  const data = text\n    .toString('utf8')\n    .split(/\\r?\\n/)\n    .filter(line => /\\S/.test(line))\n    .map(line => line.split('\\t'))\n    .filter(row => row[0] !== '')\n    .map(row => {\n      if (!currSeq || currSeq.name !== row[0]) {\n        currSeq = { name: row[0], id: idCounter }\n        idCounter += 1\n      }\n\n      return {\n        id: currSeq.id,\n        name: row[0],\n        length: +row[1],\n        start: 0,\n        end: +row[1],\n        offset: +row[2],\n        lineLength: +row[3],\n        lineBytes: +row[4],\n      }\n    })\n\n  return {\n    name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n    id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n  }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts)\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys((await this._getIndexes(opts)).name)\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as { [key: string]: number }\n    const idx = await this._getIndexes(opts)\n    const vals = Object.values(idx.id)\n    for (let i = 0; i < vals.length; i += 1) {\n      returnObject[vals[i].name] = vals[i].length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx.name[seqName]?.length\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts)).name[name]\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesById(\n    seqId: number,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).id[seqId]\n    if (!indexEntry) {\n      return undefined\n    }\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  /**\n   * @param {string} seqName\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).name[seqName]\n    if (!indexEntry) {\n      return undefined\n    }\n\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    const residues = Buffer.allocUnsafe(readlen)\n    await this.fasta.read(residues, 0, readlen, position, opts)\n    return residues.toString('utf8').replace(/\\s+/g, '')\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport IndexedFasta from './indexedFasta'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n  }) {\n    super({ fasta, path, fai, faiPath })\n    if (fasta && gzi) {\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      this.fasta = new BgzfFilehandle({ path, gziPath })\n    }\n  }\n}\n","import { IndexedFasta } from '@gmod/indexedfasta';\nimport { BaseSequenceAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { SimpleFeature } from '@jbrowse/core/util';\nimport AbortablePromiseCache from 'abortable-promise-cache';\nimport QuickLRU from '@jbrowse/core/util/QuickLRU';\nexport default class extends BaseSequenceAdapter {\n    constructor() {\n        super(...arguments);\n        this.seqCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 200 }),\n            fill: async (args, signal) => {\n                const { refName, start, end, fasta } = args;\n                return fasta.getSequence(refName, start, end, { ...args, signal });\n            },\n        });\n    }\n    async getRefNames(opts) {\n        const { fasta } = await this.setup();\n        return fasta.getSequenceNames(opts);\n    }\n    async getRegions(opts) {\n        const { fasta } = await this.setup();\n        const seqSizes = await fasta.getSequenceSizes(opts);\n        return Object.keys(seqSizes).map(refName => ({\n            refName,\n            start: 0,\n            end: seqSizes[refName],\n        }));\n    }\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        return {\n            fasta: new IndexedFasta({\n                fasta: openLocation(fastaLocation, this.pluginManager),\n                fai: openLocation(faiLocation, this.pluginManager),\n            }),\n        };\n    }\n    async getHeader() {\n        const loc = this.getConf('metadataLocation');\n        return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n            ? null\n            : openLocation(loc, this.pluginManager).readFile('utf8');\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch(e => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    getFeatures(region, opts) {\n        const { refName, start, end } = region;\n        return ObservableCreate(async (observer) => {\n            const { fasta } = await this.setup();\n            const size = await fasta.getSequenceSize(refName, opts);\n            const regionEnd = size !== undefined ? Math.min(size, end) : end;\n            const chunks = [];\n            const chunkSize = 128000;\n            const s = start - (start % chunkSize);\n            const e = end + (chunkSize - (end % chunkSize));\n            for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n                const r = {\n                    refName,\n                    start: chunkStart,\n                    end: chunkStart + chunkSize,\n                };\n                chunks.push(this.seqCache.get(JSON.stringify(r), { ...r, fasta }, opts === null || opts === void 0 ? void 0 : opts.signal));\n            }\n            const seq = (await Promise.all(chunks))\n                .join('')\n                .slice(start - s)\n                .slice(0, end - start);\n            if (seq) {\n                observer.next(new SimpleFeature({\n                    id: `${refName} ${start}-${regionEnd}`,\n                    data: { refName, start, end: regionEnd, seq },\n                }));\n            }\n            observer.complete();\n        });\n    }\n    /**\n     * called to provide a hint that data tied to a certain region\n     * will not be needed for the foreseeable future and can be purged\n     * from caches, etc\n     */\n    freeResources( /* { region } */) { }\n}\n"],"names":["_faiOffset","idx","pos","offset","lineBytes","Math","floor","lineLength","IndexedFasta","constructor","_ref","fasta","fai","path","faiPath","this","Error","LocalFile","concat","_getIndexes","opts","indexes","async","text","readFile","length","currSeq","idCounter","data","toString","split","filter","line","test","map","row","name","id","start","end","Object","fromEntries","entry","readFAI","getSequenceNames","keys","getSequenceSizes","returnObject","vals","values","i","getSequenceSize","seqName","_a","hasReferenceSequence","getResiduesById","seqId","min","max","indexEntry","_fetchFromIndexEntry","getResiduesByName","getSequence","arguments","undefined","TypeError","position","readlen","residues","Buffer","allocUnsafe","read","replace","BgzipIndexedFasta","gzi","gziPath","super","BgzfFilehandle","filehandle","gziFilehandle","BaseSequenceAdapter","seqCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","args","signal","refName","getRefNames","setup","getRegions","seqSizes","setupPre","fastaLocation","getConf","faiLocation","openLocation","pluginManager","getHeader","loc","uri","setupP","catch","e","getFeatures","region","ObservableCreate","size","regionEnd","chunks","chunkSize","s","chunkStart","r","push","get","JSON","stringify","seq","Promise","all","join","slice","observer","next","SimpleFeature","complete","freeResources"],"sourceRoot":""}