(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[4648],{99896:(e,t,a)=>{"use strict";a.r(t),a.d(t,{default:()=>h});var s=a(48591),n=a(70546),r=a(50472),i=a(10718),d=a(91855),o=a(98781),l=a(36064),c=a(98779);const h=class extends s.BaseFeatureDataAdapter{constructor(e,t,a){super(e,t,a);const s=(0,c.readConfObject)(e,"gffGzLocation"),n=(0,c.readConfObject)(e,["index","indexType"]),i=(0,c.readConfObject)(e,["index","location"]),d=(0,c.readConfObject)(e,"dontRedispatch");this.dontRedispatch=d||["chromosome","contig","region"],this.gff=new o.wD({filehandle:(0,r.openLocation)(s,this.pluginManager),csiFilehandle:"CSI"===n?(0,r.openLocation)(i,this.pluginManager):void 0,tbiFilehandle:"CSI"!==n?(0,r.openLocation)(i,this.pluginManager):void 0,chunkCacheSize:52428800,renameRefSeqs:e=>e})}async getRefNames(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.gff.getReferenceSequenceNames(e)}async getHeader(){return this.gff.getHeader()}getFeatures(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,i.ObservableCreate)((async a=>{const s=await this.gff.getMetadata();await this.getFeaturesHelper(e,t,s,a,!0)}),t.signal)}async getFeaturesHelper(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:e;try{const d=[];if(await this.gff.getLines(e.refName,e.start,e.end,((e,t)=>{d.push(this.parseLine(a.columnNumbers,e,t))})),r&&d.length){let n=1/0,r=-1/0;if(d.forEach((e=>{const t=e.fields[2];if(!this.dontRedispatch.includes(t)){const t=e.start-1;t<n&&(n=t),e.end>r&&(r=e.end)}})),r>e.end||n<e.start)return void await this.getFeaturesHelper({...e,start:n,end:r},t,a,s,!1,e)}const o=d.map((e=>(e.fields[8]&&"."!==e.fields[8]?e.fields[8].includes("_lineHash")||(e.fields[8]+=";_lineHash=".concat(e.lineHash)):e.fields[8]="_lineHash=".concat(e.lineHash),e.fields.join("\t")))).join("\n");l.A.parseStringSync(o,{parseFeatures:!0,parseComments:!1,parseDirectives:!1,parseSequences:!1,disableDerivesFromReferences:!0}).forEach((e=>this.formatFeatures(e).forEach((e=>{(0,n.doesIntersect2)(e.get("start"),e.get("end"),i.start,i.end)&&s.next(e)})))),s.complete()}catch(d){s.error(d)}}parseLine(e,t,a){const s=t.split("\t");return{start:+s[e.start-1],end:+s[e.end-1],lineHash:a,fields:s}}formatFeatures(e){return e.map((e=>new d.default({data:this.featureData(e),id:"".concat(this.id,"-offset-").concat(e.attributes._lineHash[0])})))}featureData(e){const t={...e};t.start-=1,"+"===e.strand?t.strand=1:"-"===e.strand?t.strand=-1:"."===e.strand?t.strand=0:t.strand=void 0,t.phase=Number(e.phase),t.refName=e.seq_id,null===e.score&&delete t.score,null===e.phase&&delete t.score;const a=new Set(["start","end","seq_id","score","type","source","phase","strand"]),s=e.attributes||{};for(const n of Object.keys(s)){let e=n.toLowerCase();if(a.has(e)&&(e+="2"),null!==s[n]){let a=s[n];Array.isArray(a)&&1===a.length&&([a]=a),t[e]=a}}return t.refName=t.seq_id,e.child_features&&e.child_features.length>0&&(t.subfeatures=e.child_features.flatMap((e=>e.map((e=>this.featureData(e)))))),delete t.child_features,delete t.data,delete t._linehash,delete t.attributes,delete t.seq_id,t}freeResources(){}}},15340:()=>{},79838:()=>{}}]);
//# sourceMappingURL=4648.0a26a4b3.chunk.js.map