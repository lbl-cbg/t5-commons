{"version":3,"file":"static/js/7185.b2f601b0.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-bed/esm/BedAdapter/BedAdapter.js"],"sourcesContent":["import BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { featureData } from '../util';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nclass BedAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async loadDataP(opts = {}) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedLocation');\n        const buf = await openLocation(bedLoc, pm).readFile(opts);\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const headerLines = [];\n        let i = 0;\n        for (; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const features = {};\n        for (; i < lines.length; i++) {\n            const line = lines[i];\n            const tab = line.indexOf('\\t');\n            const refName = line.slice(0, tab);\n            if (!features[refName]) {\n                features[refName] = [];\n            }\n            features[refName].push(line);\n        }\n        const autoSql = this.getConf('autoSql');\n        const parser = new BED({ autoSql });\n        const columnNames = this.getConf('columnNames');\n        const scoreColumn = this.getConf('scoreColumn');\n        const colRef = this.getConf('colRef');\n        const colStart = this.getConf('colStart');\n        const colEnd = this.getConf('colEnd');\n        return {\n            header,\n            features,\n            parser,\n            columnNames,\n            scoreColumn,\n            colRef,\n            colStart,\n            colEnd,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.bedFeatures) {\n            this.bedFeatures = this.loadDataP(opts).catch(e => {\n                this.bedFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { features } = await this.loadData(opts);\n        return Object.keys(features);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureIntervalTreeHelper(refName) {\n        const { colRef, colStart, colEnd, features, parser, scoreColumn } = await this.loadData();\n        const lines = features[refName];\n        if (!lines) {\n            return undefined;\n        }\n        const names = await this.getNames();\n        const intervalTree = new IntervalTree();\n        const ret = lines.map((f, i) => {\n            const uniqueId = `${this.id}-${refName}-${i}`;\n            return featureData(f, colRef, colStart, colEnd, scoreColumn, parser, uniqueId, names);\n        });\n        for (const obj of ret) {\n            intervalTree.insert([obj.get('start'), obj.get('end')], obj);\n        }\n        return intervalTree;\n    }\n    async loadFeatureIntervalTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(refName).catch(e => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureIntervalTree(refName);\n            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => observer.next(f));\n            observer.complete();\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nBedAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default BedAdapter;\n"],"names":["BedAdapter","BaseFeatureDataAdapter","constructor","super","arguments","this","intervalTrees","loadDataP","opts","length","undefined","pm","pluginManager","bedLoc","getConf","buf","openLocation","readFile","buffer","isGzip","unzip","Error","lines","TextDecoder","fatal","decode","split","filter","f","headerLines","i","startsWith","push","header","join","features","line","tab","indexOf","refName","slice","autoSql","parser","BED","columnNames","scoreColumn","colRef","colStart","colEnd","loadData","bedFeatures","catch","e","getRefNames","Object","keys","getHeader","getNames","defline","at","includes","map","field","trim","loadFeatureIntervalTreeHelper","names","intervalTree","IntervalTree","ret","uniqueId","concat","id","featureData","obj","insert","get","loadFeatureIntervalTree","getFeatures","query","ObservableCreate","async","start","end","search","forEach","observer","next","complete","signal","freeResources","capabilities"],"sourceRoot":""}