{"version":3,"file":"static/js/1900.cc7c6a61.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-gff3/esm/Gff3Adapter/Gff3Adapter.js"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport gff from '@gmod/gff';\nfunction isGzip(buf) {\n    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;\n}\nexport default class extends BaseFeatureDataAdapter {\n    async loadDataP() {\n        const pm = this.pluginManager;\n        const buf = await openLocation(this.getConf('gffLocation'), pm).readFile();\n        const buffer = isGzip(buf) ? await unzip(buf) : buf;\n        // 512MB  max chrome string length is 512MB\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split(/\\n|\\r\\n|\\r/);\n        const headerLines = [];\n        for (let i = 0; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const feats = gff.parseStringSync(data, {\n            parseFeatures: true,\n            parseComments: false,\n            parseDirectives: false,\n            parseSequences: false,\n            disableDerivesFromReferences: true,\n        });\n        const intervalTree = {};\n        for (const obj of feats.flat().map((f, i) => new SimpleFeature({\n            data: this.featureData(f),\n            id: `${this.id}-offset-${i}`,\n        }))) {\n            const key = obj.get('refName');\n            if (!intervalTree[key]) {\n                intervalTree[key] = new IntervalTree();\n            }\n            intervalTree[key].insert([obj.get('start'), obj.get('end')], obj);\n        }\n        return { header, intervalTree };\n    }\n    async loadData() {\n        if (!this.gffFeatures) {\n            this.gffFeatures = this.loadDataP().catch(e => {\n                this.gffFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.gffFeatures;\n    }\n    async getRefNames(_opts = {}) {\n        const { intervalTree } = await this.loadData();\n        return Object.keys(intervalTree);\n    }\n    async getHeader() {\n        const { header } = await this.loadData();\n        return header;\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = query;\n                const { intervalTree } = await this.loadData();\n                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach(f => observer.next(f));\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    featureData(data) {\n        const f = { ...data };\n        f.start -= 1; // convert to interbase\n        if (data.strand === '+') {\n            f.strand = 1;\n        }\n        else if (data.strand === '-') {\n            f.strand = -1;\n        }\n        else if (data.strand === '.') {\n            f.strand = 0;\n        }\n        else {\n            f.strand = undefined;\n        }\n        f.phase = Number(data.phase);\n        f.refName = data.seq_id;\n        if (data.score === null) {\n            delete f.score;\n        }\n        if (data.phase === null) {\n            delete f.score;\n        }\n        const defaultFields = new Set([\n            'start',\n            'end',\n            'seq_id',\n            'score',\n            'type',\n            'source',\n            'phase',\n            'strand',\n        ]);\n        const dataAttributes = data.attributes || {};\n        for (const a of Object.keys(dataAttributes)) {\n            let b = a.toLowerCase();\n            if (defaultFields.has(b)) {\n                // add \"suffix\" to tag name if it already exists\n                // reproduces behavior of NCList\n                b += '2';\n            }\n            if (dataAttributes[a] !== null) {\n                let attr = dataAttributes[a];\n                if (Array.isArray(attr) && attr.length === 1) {\n                    ;\n                    [attr] = attr;\n                }\n                f[b] = attr;\n            }\n        }\n        f.refName = f.seq_id;\n        // the SimpleFeature constructor takes care of recursively inflating subfeatures\n        if (data.child_features && data.child_features.length > 0) {\n            f.subfeatures = data.child_features.flatMap(childLocs => childLocs.map(childLoc => this.featureData(childLoc)));\n        }\n        delete f.child_features;\n        delete f.data;\n        // delete f.derived_features\n        delete f.attributes;\n        delete f.seq_id;\n        return f;\n    }\n    freeResources( /* { region } */) { }\n}\n"],"names":["BaseFeatureDataAdapter","loadDataP","pm","this","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","length","Error","data","TextDecoder","fatal","decode","lines","split","headerLines","i","startsWith","push","header","join","feats","gff","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","intervalTree","obj","flat","map","f","SimpleFeature","featureData","id","concat","key","get","IntervalTree","insert","loadData","gffFeatures","catch","e","undefined","getRefNames","Object","keys","getHeader","getFeatures","query","opts","arguments","ObservableCreate","async","_a","start","end","refName","search","forEach","observer","next","complete","error","signal","strand","phase","Number","seq_id","score","defaultFields","Set","dataAttributes","attributes","a","b","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc","freeResources"],"sourceRoot":""}