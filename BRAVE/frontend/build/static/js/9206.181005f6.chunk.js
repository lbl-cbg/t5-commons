"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[9206],{59206:(e,t,n)=>{n.r(t),n.d(t,{default:()=>S});var s=n(48591),a=n(50472),i=n(10718),r=n(91855),o=n(77353),c=n.n(o),l=n(54856),h=n(72389),d=n(91624).hp;const u=440477507;function f(e,t){const n=e.prototype[t],s="_memo_".concat(t);e.prototype[t]=function(){return s in this||(this[s]=n.call(this)),this[s]}}const g=["T","C","A","G"],w=[];for(let y=0;y<256;y++)w.push(g[y>>6&3]+g[y>>4&3]+g[y>>2&3]+g[3&y]);const m=w.map((e=>e.toLowerCase()));class p{constructor(e){let{filehandle:t,path:n}=e;if(t)this.filehandle=t;else{if(!n)throw new Error("must supply path or filehandle");this.filehandle=new l.LocalFile(n)}this.isBigEndian=void 0}async _getParser(e){const t=(await this._getParsers())[e];if(!t)throw new Error("parser ".concat(e," not found"));return t}async _detectEndianness(){const e=await this.filehandle.read(d.allocUnsafe(8),0,8,0),{buffer:t}=e;if(t.readInt32LE(0)===u)this.isBigEndian=!1,this.version=t.readInt32LE(4);else{if(t.readInt32BE(0)!==u)throw new Error("not a 2bit file");this.isBigEndian=!0,this.version=t.readInt32BE(4)}}async _getParsers(){await this._detectEndianness();const e=this.isBigEndian?"big":"little",t=this.isBigEndian?"be":"le";let n=(new h.i).endianess(e).uint8("nameLength").string("name",{length:"nameLength"});n=1===this.version?n.buffer("offsetBytes",{length:8}):n.uint32("offset");return{header:(new h.i).endianess(e).int32("magic",{assert:e=>440477507===e}).int32("version",{assert:e=>0===e||1===e}).uint32("sequenceCount",{assert:e=>e>=0}).uint32("reserved"),index:(new h.i).endianess(e).uint32("sequenceCount").uint32("reserved").array("index",{length:"sequenceCount",type:n}),record1:(new h.i).endianess(e).uint32("dnaSize").uint32("nBlockCount"),record2:(new h.i).endianess(e).uint32("nBlockCount").array("nBlockStarts",{length:"nBlockCount",type:"uint32".concat(t)}).array("nBlockSizes",{length:"nBlockCount",type:"uint32".concat(t)}).uint32("maskBlockCount"),record3:(new h.i).endianess(e).uint32("maskBlockCount").array("maskBlockStarts",{length:"maskBlockCount",type:"uint32".concat(t)}).array("maskBlockSizes",{length:"maskBlockCount",type:"uint32".concat(t)}).int32("reserved")}}async getHeader(){await this._detectEndianness();const{buffer:e}=await this.filehandle.read(d.allocUnsafe(16),0,16,0);return(await this._getParser("header")).parse(e).result}async getIndex(){const e=8+(await this.getHeader()).sequenceCount*(257+(1===this.version?8:4)),{buffer:t}=await this.filehandle.read(d.allocUnsafe(e),0,e,8),n=(await this._getParser("index")).parse(t).result.index,s={};return 1===this.version?n.forEach((e=>{let{name:t,offsetBytes:n}=e;const a=c().fromBytes(n,!0,!this.isBigEndian);if(a.greaterThan(Number.MAX_SAFE_INTEGER))throw new Error("integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.");s[t]=a.toNumber()})):n.forEach((e=>{let{name:t,offset:n}=e;s[t]=n})),s}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),n=Object.values(e).map((e=>this._getSequenceSize(e))),s=await Promise.all(n),a={};for(let i=0;i<t.length;i+=1)a[t[i]]=s[i];return a}async getSequenceSize(e){const t=(await this.getIndex())[e];if(t)return this._getSequenceSize(t)}async _getSequenceSize(e){if(void 0===e||e<0)throw new Error("invalid offset");return(await this._parseItem(e,8,"record1")).dnaSize}async _getSequenceRecord(e){if(void 0===e||e<0)throw new Error("invalid offset");const t=await this._parseItem(e,8,"record1"),n=8*t.nBlockCount+8,s=await this._parseItem(e+4,n,"record2"),a=8*s.maskBlockCount+8,i=await this._parseItem(e+4+n-4,a,"record3");return{dnaSize:t.dnaSize,nBlocks:{starts:s.nBlockStarts,sizes:s.nBlockSizes},maskBlocks:{starts:i.maskBlockStarts,sizes:i.maskBlockSizes},dnaPosition:e+4+n-4+a}}async _parseItem(e,t,n){const{buffer:s}=await this.filehandle.read(d.allocUnsafe(t),0,t,e);return(await this._getParser(n)).parse(s).result}async getSequence(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2?arguments[2]:void 0;const s=(await this.getIndex())[e];if(!s)return;const a=await this._getSequenceRecord(s);if(t<0)throw new TypeError("regionStart cannot be less than 0");(void 0===n||n>a.dnaSize)&&(n=a.dnaSize);const i=this._getOverlappingBlocks(t,n,a.nBlocks.starts,a.nBlocks.sizes),r=this._getOverlappingBlocks(t,n,a.maskBlocks.starts,a.maskBlocks.sizes),o=d.allocUnsafe(Math.ceil((n-t)/4)+1),c=Math.floor(t/4),{buffer:l}=await this.filehandle.read(o,0,o.length,a.dnaPosition+c);let h="";for(let d=t;d<n;d+=1){for(;r.length&&r[0].end<=d;)r.shift();const e=r[0]&&r[0].start<=d&&r[0].end>d;if(i[0]&&d>=i[0].start&&d<i[0].end){const t=i.shift();for(;d<t.end&&d<n;d+=1)h+=e?"n":"N";d-=1}else{const t=d%4,n=l[Math.floor(d/4)-c];h+=e?m[n][t]:w[n][t]}}return h}_getOverlappingBlocks(e,t,n,s){let a,i;for(let o=0;o<n.length;o+=1){const r=n[o];if(e>=r+s[o]||t<=r){if(void 0!==a){i=o;break}}else void 0===a&&(a=o)}if(void 0===a)return[];void 0===i&&(i=n.length);const r=new Array(i-a);for(let o=a;o<i;o+=1)r[o-a]={start:n[o],end:n[o]+s[o],size:s[o]};return r}}f(p,"_getParsers"),f(p,"getIndex"),f(p,"getHeader");var k=n(98779);class S extends s.BaseSequenceAdapter{async initChromSizes(){const e=(0,k.readConfObject)(this.config,"chromSizesLocation");if("/path/to/default.chrom.sizes"!==e.uri&&""!==e.uri){const t=(0,a.openLocation)(e,this.pluginManager),n=await t.readFile("utf8");return Object.fromEntries(null===n||void 0===n?void 0:n.split(/\n|\r\n|\r/).filter((e=>!!e.trim())).map((e=>{const[t,n]=e.split("\t");return[t,+n]})))}}constructor(e,t,n){super(e,t,n);const s=this.pluginManager;this.chromSizesData=this.initChromSizes(),this.twobit=new p({filehandle:(0,a.openLocation)(this.getConf("twoBitLocation"),s)})}async getRefNames(){const e=await this.chromSizesData;return e?Object.keys(e):this.twobit.getSequenceNames()}async getRegions(){const e=await this.chromSizesData;if(e)return Object.keys(e).map((t=>({refName:t,start:0,end:e[t]})));const t=await this.twobit.getSequenceSizes();return Object.keys(t).map((e=>({refName:e,start:0,end:t[e]})))}getFeatures(e){let{refName:t,start:n,end:s}=e;return(0,i.ObservableCreate)((async e=>{const a=await this.twobit.getSequenceSize(t),i=void 0!==a?Math.min(a,s):s,o=await this.twobit.getSequence(t,n,i);o&&e.next(new r.default({id:"".concat(t," ").concat(n,"-").concat(i),data:{refName:t,start:n,end:i,seq:o}})),e.complete()}))}freeResources(){}}}}]);
//# sourceMappingURL=9206.181005f6.chunk.js.map