{"version":3,"file":"static/js/8545.9541a100.chunk.js","mappings":"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","sources":["../node_modules/@gmod/nclist/src/util.ts","../node_modules/@gmod/nclist/src/nclist.ts","../node_modules/@gmod/nclist/src/array_representation.ts","../node_modules/@gmod/nclist/src/lazy_array.ts","../node_modules/@gmod/nclist/src/feature_store.ts","../node_modules/@gmod/nclist/src/index.ts","../node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListFeature.js","../node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListAdapter.js"],"sourcesContent":["//@ts-nocheck\nexport async function readJSON(url, readFile, options = {}) {\n  const { defaultContent = {} } = options\n  let str\n  try {\n    str = await readFile(url, { encoding: 'utf8' })\n    return JSON.parse(str)\n  } catch (error) {\n    if (error.code === 'ENOENT' || error.status === 404) {\n      return defaultContent\n    }\n    throw error\n  }\n}\n\nexport function foo() {}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\nexport default class NCList {\n  constructor({ readFile, cacheSize = 100 }) {\n    this.topList = []\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.readChunkItems.bind(this),\n    })\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function`)\n    }\n  }\n\n  importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n    this.topList = nclist\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    this.lazyClass = lazyClass\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n  }\n\n  binarySearch(arr, item, getter) {\n    let low = -1\n    let high = arr.length\n    let mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (getter(arr[mid]) >= item) {\n        high = mid\n      } else {\n        low = mid\n      }\n    }\n\n    // if we're iterating rightward, return the high index;\n    // if leftward, the low index\n    if (getter === this.end) {\n      return high\n    }\n    return low\n  }\n\n  readChunkItems(chunkNum) {\n    const url = nodeUrl.resolve(\n      this.baseURL,\n      this.lazyUrlTemplate.replace(/\\{Chunk\\}/gi, chunkNum),\n    )\n    return readJSON(url, this.readFile, { defaultContent: [] })\n  }\n\n  async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {\n    const getChunk = this.attrs.makeGetter('Chunk')\n    const getSublist = this.attrs.makeGetter('Sublist')\n\n    const pendingPromises = []\n    for (\n      let i = this.binarySearch(arr, from, searchGet);\n      i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to;\n      i += inc\n    ) {\n      if (arr[i][0] === this.lazyClass) {\n        // this is a lazily-loaded chunk of the nclist\n        const chunkNum = getChunk(arr[i])\n        const chunkItemsP = this.chunkCache\n          .get(chunkNum, chunkNum)\n          .then(item => [item, chunkNum])\n        pendingPromises.push(chunkItemsP)\n      } else {\n        // this is just a regular feature\n        yield [arr[i], path.concat(i)]\n      }\n\n      // if this node has a contained sublist, process that too\n      const sublist = getSublist(arr[i])\n      if (sublist) {\n        yield* this.iterateSublist(\n          sublist,\n          from,\n          to,\n          inc,\n          searchGet,\n          testGet,\n          path.concat(i),\n        )\n      }\n    }\n\n    for (let i = 0; i < pendingPromises.length; i += 1) {\n      const [item, chunkNum] = await pendingPromises[i]\n      if (item) {\n        yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [\n          ...path,\n          chunkNum,\n        ])\n      }\n    }\n  }\n\n  async *iterate(from, to) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    // if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    // inc: iterate leftward or rightward\n    const inc = from > to ? -1 : 1\n    // searchGet: search on start or end\n    const searchGet = from > to ? this.start : this.end\n    // testGet: test on start or end\n    const testGet = from > to ? this.end : this.start\n\n    if (this.topList.length > 0) {\n      yield* this.iterateSublist(\n        this.topList,\n        from,\n        to,\n        inc,\n        searchGet,\n        testGet,\n        [0],\n      )\n    }\n  }\n\n  async histogram(from, to, numBins) {\n    // calls callback with a histogram of the feature density\n    // in the given interval\n\n    const result = new Array(numBins)\n    result.fill(0)\n    const binWidth = (to - from) / numBins\n    for await (const feat of this.iterate(from, to)) {\n      const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0)\n      const lastBin = Math.min(\n        numBins,\n        ((this.end(feat) - from) / binWidth) | 0,\n      )\n      for (let bin = firstBin; bin <= lastBin; bin += 1) {\n        result[bin] += 1\n      }\n    }\n    return result\n  }\n}\n","//@ts-nocheck\n/**\n * @class ArrayRepr\n *\n * Class for operating on indexed array representations of objects.\n *\n * For example, if we have a lot of objects with similar attrbutes, e.g.:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: -1},\n *         {start: 5, end: 6, strand: 1},\n *         ...\n *     ]\n * </pre>\n *\n * @description\n * we can represent them more compactly (e.g., in JSON) something like this:\n *\n * <pre class=\"code\">\n *     class = [\"start\", \"end\", \"strand\"]\n *     [\n *         [1, 2, -1],\n *         [5, 6, 1],\n *         ...\n *     ]\n * </pre>\n *\n * If we want to represent a few different kinds of objects in our big list,\n * we can have multiple \"class\" arrays, and tag each object to identify\n * which \"class\" array describes it.\n *\n * For example, if we have a lot of instances of a few types of objects,\n * like this:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: 1, id: 1},\n *         {start: 5, end: 6, strand: 1, id: 2},\n *         ...\n *         {start: 10, end: 20, chunk: 1},\n *         {start: 30, end: 40, chunk: 2},\n *         ...\n *     ]\n * </pre>\n *\n * We could use the first array position to indicate the \"class\" for the\n * object, like this:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2],\n *         ...\n *         [1, 10, 20, 1],\n *         [1, 30, 40, 1]\n *     ]\n * </pre>\n *\n * Also, if we occasionally want to add an ad-hoc attribute, we could just\n * stick an optional dictionary onto the end:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2, {foo: 1}]\n *     ]\n * </pre>\n *\n * Given that individual objects are being represented by arrays, generic\n * code needs some way to differentiate arrays that are meant to be objects\n * from arrays that are actually meant to be arrays.\n * So for each class, we include a dict with <attribute name>: true mappings\n * for each attribute that is meant to be an array.\n *\n * Also, in cases where some attribute values are the same for all objects\n * in a particular set, it may be convenient to define a \"prototype\"\n * with default values for all objects in the set\n *\n * In the end, we get something like this:\n *\n * <pre class=\"code\">\n *     classes=[\n *         {'attributes': ['Start', 'End', 'Subfeatures'],\n *          'proto': {'Chrom': 'chr1'},\n *          'isArrayAttr': {Subfeatures: true}}\n *         ]\n * </pre>\n *\n * That's what this class facilitates.\n */\nclass ArrayRepr {\n  constructor(classes) {\n    this.classes = classes\n    this.fields = []\n    for (let cl = 0; cl < classes.length; cl += 1) {\n      this.fields[cl] = {}\n      for (let f = 0; f < classes[cl].attributes.length; f += 1) {\n        this.fields[cl][classes[cl].attributes[f]] = f + 1\n      }\n      if (classes[cl].proto === undefined) {\n        classes[cl].proto = {}\n      }\n      if (classes[cl].isArrayAttr === undefined) {\n        classes[cl].isArrayAttr = {}\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  attrIndices(attr) {\n    return this.classes.map(\n      x =>\n        x.attributes.indexOf(attr) + 1 ||\n        x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n        undefined,\n    )\n  }\n\n  get(obj, attr) {\n    if (attr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][attr]]\n    }\n\n    // try lowercase\n    const lcattr = attr.toLowerCase()\n    if (lcattr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][lcattr]]\n    }\n\n    const adhocIndex = this.classes[obj[0]].attributes.length + 1\n    if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n      if (attr in this.classes[obj[0]].proto) {\n        return this.classes[obj[0]].proto[attr]\n      }\n      return undefined\n    }\n    return obj[adhocIndex][attr]\n  }\n\n  makeSetter(attr) {\n    return (obj, val) => {\n      this.set(obj, attr, val)\n    }\n  }\n\n  makeGetter(attr) {\n    return obj => {\n      return this.get(obj, attr)\n    }\n  }\n\n  makeFastGetter(attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    const indices = this.attrIndices(attr)\n    return function get(obj) {\n      if (indices[obj[0]] !== undefined) {\n        return obj[indices[obj[0]]]\n      }\n      return undefined\n    }\n  }\n\n  // construct(self, obj, klass) {\n  //   const result = new Array(self.classes[klass].length)\n  //   Object.keys(obj).forEach(attr => {\n  //     this.set(result, attr, obj[attr])\n  //   })\n  //   return result\n  // }\n\n  /**\n   * Returns fast pre-compiled getter and setter functions for use with\n   * Arrays that use this representation.\n   * When the returned <code>get</code> and <code>set</code> functions are\n   * added as methods to an Array that contains data in this\n   * representation, they provide fast access by name to the data.\n   *\n   * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n   *\n   * @example\n   * var accessors = attrs.accessors();\n   * var feature = get_feature_from_someplace();\n   * feature.get = accessors.get;\n   * // print out the feature start and end\n   * console.log( feature.get('start') + ',' + feature.get('end') );\n   */\n  accessors() {\n    if (!this._accessors) {\n      this._accessors = this._makeAccessors()\n    }\n    return this._accessors\n  }\n\n  /**\n   * @private\n   */\n  _makeAccessors() {\n    const indices = {}\n\n    const accessors = {\n      get(field) {\n        const f = this.get.field_accessors[field.toLowerCase()]\n        if (f) {\n          return f.call(this)\n        }\n        return undefined\n      },\n      set(field, val) {\n        const f = this.set.field_accessors[field]\n        if (f) {\n          return f.call(this, val)\n        }\n        return undefined\n      },\n      tags() {\n        return tags[this[0]] || []\n      },\n    }\n    accessors.get.field_accessors = {}\n    accessors.set.field_accessors = {}\n\n    // make a data structure as: { attr_name: [offset,offset,offset], }\n    // that will be convenient for finding the location of the attr\n    // for a given class like: indexForAttr{attrname}[classnum]\n    this.classes.forEach((cdef, classnum) => {\n      ;(cdef.attributes || []).forEach((attrname, offset) => {\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n\n        attrname = attrname.toLowerCase()\n\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n      })\n    })\n\n    // lowercase all the class attributes\n    const tags = this.classes.map(c => c.attributes)\n\n    // use that to make precalculated get and set accessors for each field\n    Object.keys(indices).forEach(attrname => {\n      const attrIndices = indices[attrname]\n      // get\n      accessors.get.field_accessors[attrname] = !attrIndices\n        ? function get() {\n            return undefined\n          }\n        : function get() {\n            return this[attrIndices[this[0]]]\n          }\n\n      // // set\n      // accessors.set.field_accessors[attrname] = !attrIndices\n      //   ? () => undefined\n      //   : v => {\n      //       this[attrIndices[this[0]]] = v\n      //       return v\n      //     }\n    })\n\n    return accessors\n  }\n}\nexport default ArrayRepr\n\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\n/**\n * For a JSON array that gets too large to load in one go, this class\n * helps break it up into chunks and provides an\n * async API for using the information in the array.\n */\nexport default class LazyArray {\n  constructor(\n    { urlTemplate, chunkSize, length, cacheSize = 100, readFile },\n    baseUrl,\n  ) {\n    this.urlTemplate = urlTemplate\n    this.chunkSize = chunkSize\n    this.length = length\n    this.baseUrl = baseUrl === undefined ? '' : baseUrl\n    this.readFile = readFile\n    if (!readFile) {\n      throw new Error('must provide readFile callback')\n    }\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.getChunk.bind(this),\n    })\n  }\n\n  /**\n   * call the callback on one element of the array\n   * @param i index\n   * @param callback callback, gets called with (i, value, param)\n   * @param param (optional) callback will get this as its last parameter\n   */\n  index(i, callback, param) {\n    this.range(i, i, callback, undefined, param)\n  }\n\n  /**\n   * async generator for the elements in the range [start,end]\n   *\n   * @param start index of first element to call the callback on\n   * @param end index of last element to call the callback on\n   */\n  async *range(start, end) {\n    start = Math.max(0, start)\n    end = Math.min(end, this.length - 1)\n\n    const firstChunk = Math.floor(start / this.chunkSize)\n    const lastChunk = Math.floor(end / this.chunkSize)\n\n    const chunkreadFiles = []\n    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n      chunkreadFiles.push(this.chunkCache.get(chunk, chunk))\n    }\n    for (let i = 0; i < chunkreadFiles.length; i += 1) {\n      const [chunkNumber, chunkData] = await chunkreadFiles[i]\n      yield* this.filterChunkData(start, end, chunkNumber, chunkData)\n    }\n  }\n\n  async getChunk(chunkNumber) {\n    let url = this.urlTemplate.replace(/\\{Chunk\\}/gi, chunkNumber)\n    if (this.baseUrl) {\n      url = nodeUrl.resolve(this.baseUrl, url)\n    }\n    const data = await readJSON(url, this.readFile)\n    return [chunkNumber, data]\n  }\n\n  *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {\n    // index (in the overall lazy array) of the first position in this chunk\n    const firstIndex = chunkNumber * this.chunkSize\n    const chunkStart = Math.max(0, queryStart - firstIndex)\n    const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1)\n    for (let i = chunkStart; i <= chunkEnd; i += 1) {\n      yield [i + firstIndex, chunkData[i]]\n    }\n  }\n}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\n\nimport GenericNCList from './nclist'\nimport ArrayRepr from './array_representation'\nimport LazyArray from './lazy_array'\nimport { readJSON } from './util'\n\nfunction idfunc() {\n  return this._uniqueID\n}\nfunction parentfunc() {\n  return this._parent\n}\nfunction childrenfunc() {\n  return this.get('subfeatures')\n}\n\n/**\n * Sequence feature store using nested containment\n * lists held in JSON files that are lazily read.\n *\n * @param {object} args constructor args\n * @param {string} args.baseUrl base URL for resolving relative URLs\n * @param {string} args.urlTemplate Template string for\n *  the root file of each reference sequence. The reference sequence\n *  name will be interpolated into this string where `{refseq}` appears.\n * @param {function} args.readFile function to use for reading remote from URLs.\n */\nexport default class NCListStore {\n  constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {\n    this.baseUrl = baseUrl\n    this.urlTemplates = { root: urlTemplate }\n\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function argument`)\n    }\n\n    this.dataRootCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.fetchDataRoot.bind(this),\n    })\n  }\n\n  makeNCList() {\n    return new GenericNCList({ readFile: this.readFile })\n  }\n\n  loadNCList(refData, trackInfo, listUrl) {\n    refData.nclist.importExisting(\n      trackInfo.intervals.nclist,\n      refData.attrs,\n      listUrl,\n      trackInfo.intervals.urlTemplate,\n      trackInfo.intervals.lazyClass,\n    )\n  }\n\n  getDataRoot(refName) {\n    return this.dataRootCache.get(refName, refName)\n  }\n\n  fetchDataRoot(refName) {\n    const url = nodeUrl.resolve(\n      this.baseUrl,\n      this.urlTemplates.root.replace(/{\\s*refseq\\s*}/g, refName),\n    )\n\n    // fetch the trackdata\n    return readJSON(url, this.readFile).then(trackInfo =>\n      // trackInfo = JSON.parse( trackInfo );\n      this.parseTrackInfo(trackInfo, url),\n    )\n  }\n\n  parseTrackInfo(trackInfo, url) {\n    const refData = {\n      nclist: this.makeNCList(),\n      stats: {\n        featureCount: trackInfo.featureCount || 0,\n      },\n    }\n\n    if (trackInfo.intervals) {\n      refData.attrs = new ArrayRepr(trackInfo.intervals.classes)\n      this.loadNCList(refData, trackInfo, url)\n    }\n\n    const { histograms } = trackInfo\n    if (histograms && histograms.meta) {\n      for (let i = 0; i < histograms.meta.length; i += 1) {\n        histograms.meta[i].lazyArray = new LazyArray(\n          { ...histograms.meta[i].arrayParams, readFile: this.readFile },\n          url,\n        )\n      }\n      refData._histograms = histograms\n    }\n\n    // parse any strings in the histogram data that look like numbers\n    if (refData._histograms) {\n      Object.keys(refData._histograms).forEach(key => {\n        const entries = refData._histograms[key]\n        entries.forEach(entry => {\n          Object.keys(entry).forEach(key2 => {\n            if (\n              typeof entry[key2] === 'string' &&\n              String(Number(entry[key2])) === entry[key2]\n            ) {\n              entry[key2] = Number(entry[key2])\n            }\n          })\n        })\n      })\n    }\n\n    return refData\n  }\n\n  async getRegionStats(query) {\n    const data = await this.getDataRoot(query.ref)\n    return data.stats\n  }\n\n  /**\n   * fetch binned counts of feature coverage in the given region.\n   *\n   * @param {object} query\n   * @param {string} query.refName reference sequence name\n   * @param {number} query.start region start\n   * @param {number} query.end region end\n   * @param {number} query.numBins number of bins desired in the feature counts\n   * @param {number} query.basesPerBin number of bp desired in each feature counting bin\n   * @returns {object} as:\n   *    `{ bins: hist, stats: statEntry }`\n   */\n  async getRegionFeatureDensities({\n    refName,\n    start,\n    end,\n    numBins,\n    basesPerBin,\n  }) {\n    const data = await this.getDataRoot(refName)\n    if (numBins) {\n      basesPerBin = (end - start) / numBins\n    } else if (basesPerBin) {\n      numBins = Math.ceil((end - start) / basesPerBin)\n    } else {\n      throw new TypeError(\n        'numBins or basesPerBin arg required for getRegionFeatureDensities',\n      )\n    }\n\n    // pick the relevant entry in our pre-calculated stats\n    const stats = data._histograms.stats || []\n    const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin)\n\n    // The histogramMeta array describes multiple levels of histogram detail,\n    // going from the finest (smallest number of bases per bin) to the\n    // coarsest (largest number of bases per bin).\n    // We want to use coarsest histogramMeta that's at least as fine as the\n    // one we're currently rendering.\n    // TODO: take into account that the histogramMeta chosen here might not\n    // fit neatly into the current histogram (e.g., if the current histogram\n    // is at 50,000 bases/bin, and we have server histograms at 20,000\n    // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta\n    // rather than the 20,000)\n    let histogramMeta = data._histograms.meta[0]\n    for (let i = 0; i < data._histograms.meta.length; i += 1) {\n      if (basesPerBin >= data._histograms.meta[i].basesPerBin) {\n        histogramMeta = data._histograms.meta[i]\n      }\n    }\n\n    // number of bins in the server-supplied histogram for each current bin\n    let binRatio = basesPerBin / histogramMeta.basesPerBin\n\n    // if the server-supplied histogram fits neatly into our requested\n    if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n      // console.log('server-supplied',query);\n      // we can use the server-supplied counts\n      const firstServerBin = Math.floor(start / histogramMeta.basesPerBin)\n      binRatio = Math.round(binRatio)\n      const histogram = []\n      for (let bin = 0; bin < numBins; bin += 1) {\n        histogram[bin] = 0\n      }\n\n      for await (const [i, val] of histogramMeta.lazyArray.range(\n        firstServerBin,\n        firstServerBin + binRatio * numBins - 1,\n      )) {\n        // this will count features that span the boundaries of\n        // the original histogram multiple times, so it's not\n        // perfectly quantitative.  Hopefully it's still useful, though.\n        histogram[Math.floor((i - firstServerBin) / binRatio)] += val\n      }\n      return { bins: histogram, stats: statEntry }\n    }\n    // console.log('make own',query);\n    // make our own counts\n    const hist = await data.nclist.histogram(start, end, numBins)\n    return { bins: hist, stats: statEntry }\n  }\n\n  /**\n   * Fetch features in a given region. This method is an asynchronous generator\n   * yielding feature objects.\n   *\n   * @param {object} args\n   * @param {string} args.refName reference sequence name\n   * @param {number} args.start start of region. 0-based half-open.\n   * @param {number} args.end end of region. 0-based half-open.\n   * @yields {object}\n   */\n  async *getFeatures({ refName, start, end }) {\n    const data = await this.getDataRoot(refName)\n    const accessors = data.attrs && data.attrs.accessors()\n    for await (const [feature, path] of data.nclist.iterate(start, end)) {\n      // the unique ID is a stringification of the path in the\n      // NCList where the feature lives; it's unique across the\n      // top-level NCList (the top-level NCList covers a\n      // track/chromosome combination)\n\n      // only need to decorate a feature once\n      if (!feature.decorated) {\n        const uniqueID = path.join(',')\n        this.decorateFeature(accessors, feature, `${refName},${uniqueID}`)\n      }\n      yield feature\n    }\n  }\n\n  // helper method to recursively add .get and .tags methods to a feature and its\n  // subfeatures\n  decorateFeature(accessors, feature, id, parent) {\n    feature.get = accessors.get\n    feature.tags = accessors.tags\n    feature._uniqueID = id\n    feature.id = idfunc\n    feature._parent = parent\n    feature.parent = parentfunc\n    feature.children = childrenfunc\n    ;(feature.get('subfeatures') || []).forEach((f, i) => {\n      this.decorateFeature(accessors, f, `${id}-${i}`, feature)\n    })\n    feature.decorated = true\n  }\n}\n","//@ts-nocheck\nimport NCListStore from './feature_store'\n\nexport default NCListStore\n","const jb2ToJb1 = { refName: 'seq_id' };\nconst jb1ToJb2 = { seq_id: 'refName' };\n/**\n * wrapper to adapt nclist features to act like jbrowse 2 features\n */\nexport default class NCListFeature {\n    constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ncFeature, parent, id) {\n        this.ncFeature = ncFeature;\n        this.uniqueId = id || ncFeature.id();\n        this.parentHandle = parent;\n    }\n    set() {\n        throw new Error('not implemented');\n    }\n    jb2TagToJb1Tag(tag) {\n        // @ts-expect-error\n        const mapped = jb2ToJb1[tag] || tag;\n        return mapped.toLowerCase();\n    }\n    jb1TagToJb2Tag(tag) {\n        const t = tag.toLowerCase();\n        // @ts-expect-error\n        return jb1ToJb2[t] || t;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(attrName) {\n        const attr = this.ncFeature.get(this.jb2TagToJb1Tag(attrName));\n        if (attr && attrName === 'subfeatures') {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return attr.map((subfeature) => new NCListFeature(subfeature, this));\n        }\n        return attr;\n    }\n    /**\n     * Get an array listing which data keys are present in this feature.\n     */\n    tags() {\n        return this.ncFeature.tags().map((t) => this.jb1TagToJb2Tag(t));\n    }\n    /**\n     * Get the unique ID of this feature.\n     */\n    id() {\n        return this.uniqueId;\n    }\n    /**\n     * Get this feature's parent feature, or undefined if none.\n     */\n    parent() {\n        return this.parentHandle;\n    }\n    /**\n     * Get an array of child features, or undefined if none.\n     */\n    children() {\n        return this.get('subfeatures');\n    }\n    toJSON() {\n        const data = { uniqueId: this.id() };\n        this.ncFeature.tags().forEach((tag) => {\n            const mappedTag = this.jb1TagToJb2Tag(tag);\n            const value = this.ncFeature.get(tag);\n            if (mappedTag === 'subfeatures') {\n                data.subfeatures = (value || []).map((f) => {\n                    // note: was new NCListFeature(f, `${this.id()}-${i}`, this).toJSON()\n                    return new NCListFeature(f, this).toJSON();\n                });\n            }\n            else {\n                data[mappedTag] = value;\n            }\n        });\n        return data;\n    }\n}\n","import NCListStore from '@gmod/nclist';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkAbortSignal } from '@jbrowse/core/util';\nimport { RemoteFile } from 'generic-filehandle';\nimport NCListFeature from './NCListFeature';\nexport default class NCListAdapter extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const refNames = this.getConf('refNames');\n        const rootUrlTemplate = this.getConf('rootUrlTemplate');\n        this.configRefNames = refNames;\n        this.nclist = new NCListStore({\n            baseUrl: '',\n            urlTemplate: rootUrlTemplate.uri,\n            readFile: (url) => new RemoteFile(String(rootUrlTemplate.baseUri\n                ? new URL(url, rootUrlTemplate.baseUri).toString()\n                : url)).readFile(),\n        });\n    }\n    /**\n     * Fetch features for a certain region. Use getFeaturesInRegion() if you also\n     * want to verify that the store has features for the given reference sequence\n     * before fetching.\n     * @param region -\n     * @param opts - [signal] optional signalling object for aborting the fetch\n     * @returns Observable of Feature objects in the region\n     */\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { signal } = opts;\n            for await (const feature of this.nclist.getFeatures(region, opts)) {\n                checkAbortSignal(signal);\n                observer.next(this.wrapFeature(feature));\n            }\n            observer.complete();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    wrapFeature(ncFeature) {\n        return new NCListFeature(ncFeature, undefined, `${this.id}-${ncFeature.id()}`);\n    }\n    async hasDataForRefName(refName) {\n        var _a;\n        const root = await this.nclist.getDataRoot(refName);\n        return !!((_a = root === null || root === void 0 ? void 0 : root.stats) === null || _a === void 0 ? void 0 : _a.featureCount);\n    }\n    /**\n     * NCList is unable to get list of ref names so returns empty\n     */\n    async getRefNames() {\n        return this.configRefNames || [];\n    }\n    /**\n     * called to provide a hint that data tied to a certain region\n     * will not be needed for the foreseeable future and can be purged\n     * from caches, etc\n     */\n    freeResources() { }\n}\n"],"names":["async","readJSON","url","readFile","options","arguments","length","undefined","defaultContent","str","encoding","JSON","parse","error","code","status","NCList","constructor","_ref","cacheSize","this","topList","chunkCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","readChunkItems","bind","Error","importExisting","nclist","attrs","baseURL","lazyUrlTemplate","lazyClass","start","makeFastGetter","end","binarySearch","arr","item","getter","mid","low","high","chunkNum","nodeUrl","replace","iterateSublist","from","to","inc","searchGet","testGet","path","getChunk","makeGetter","getSublist","pendingPromises","i","chunkItemsP","get","then","push","concat","sublist","iterate","histogram","numBins","result","Array","binWidth","feat","firstBin","Math","max","lastBin","min","bin","classes","fields","cl","f","attributes","proto","isArrayAttr","attrIndices","attr","map","x","indexOf","toLowerCase","obj","lcattr","adhocIndex","makeSetter","val","set","indices","accessors","_accessors","_makeAccessors","field","field_accessors","call","tags","forEach","cdef","classnum","attrname","offset","c","Object","keys","LazyArray","baseUrl","urlTemplate","chunkSize","index","callback","param","range","firstChunk","floor","lastChunk","chunkreadFiles","chunk","chunkNumber","chunkData","filterChunkData","queryStart","queryEnd","firstIndex","chunkStart","chunkEnd","idfunc","_uniqueID","parentfunc","_parent","childrenfunc","urlTemplates","root","dataRootCache","fetchDataRoot","makeNCList","GenericNCList","loadNCList","refData","trackInfo","listUrl","intervals","getDataRoot","refName","parseTrackInfo","stats","featureCount","ArrayRepr","histograms","meta","lazyArray","arrayParams","_histograms","key","entry","key2","String","Number","getRegionStats","query","ref","getRegionFeatureDensities","_ref2","basesPerBin","data","TypeError","ceil","statEntry","find","histogramMeta","binRatio","abs","round","firstServerBin","bins","getFeatures","_ref3","_this","feature","decorated","uniqueID","join","decorateFeature","e","Promise","reject","id","parent","children","jb2ToJb1","jb1ToJb2","seq_id","NCListFeature","ncFeature","uniqueId","parentHandle","jb2TagToJb1Tag","tag","jb1TagToJb2Tag","t","attrName","subfeature","toJSON","mappedTag","value","subfeatures","NCListAdapter","BaseFeatureDataAdapter","config","getSubAdapter","pluginManager","super","refNames","getConf","rootUrlTemplate","configRefNames","NCListStore","uri","RemoteFile","baseUri","URL","toString","region","opts","ObservableCreate","signal","checkAbortSignal","observer","next","wrapFeature","complete","hasDataForRefName","_a","getRefNames","freeResources"],"sourceRoot":""}