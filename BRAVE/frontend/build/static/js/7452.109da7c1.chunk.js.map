{"version":3,"file":"static/js/7452.109da7c1.chunk.js","mappings":"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ACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,SACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,UACA,WACA,WACA,WACA,YAEF,SAASC,EAAaC,GACp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","sources":["../node_modules/@gmod/bam/src/virtualOffset.ts","../node_modules/@gmod/bam/src/chunk.ts","../node_modules/@gmod/bam/src/util.ts","../node_modules/@gmod/bam/src/indexFile.ts","../node_modules/@gmod/bam/src/bai.ts","../node_modules/@gmod/bam/node_modules/buffer-crc32/dist/index.mjs","../node_modules/@gmod/bam/src/csi.ts","../node_modules/@gmod/bam/src/constants.ts","../node_modules/@gmod/bam/src/record.ts","../node_modules/@gmod/bam/src/sam.ts","../node_modules/@gmod/bam/src/bamFile.ts","../node_modules/@gmod/bam/src/htsget.ts","../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js","../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamAdapter.js"],"sourcesContent":["export default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public buffer?: Buffer\n\n  constructor(\n    public minv: VirtualOffset,\n    public maxv: VirtualOffset,\n    public bin: number,\n    public _fetchedSize?: number,\n  ) {}\n\n  toUniqueString() {\n    return `${this.minv.toString()}..${this.maxv.toString()} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import Long from 'long'\nimport Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function longToNumber(long: Long) {\n  if (\n    long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n    long.lessThan(Number.MIN_SAFE_INTEGER)\n  ) {\n    throw new Error('integer overflow')\n  }\n  return long.toNumber()\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException === 'undefined') {\n      const e = new Error('aborted')\n      //@ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    } else {\n      throw new DOMException('aborted', 'AbortError')\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : obj\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest?: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | undefined\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif\n  })\n\n  for (const chunk of chunks) {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === undefined) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  }\n\n  return mergedChunks\n}\n\nexport function parsePseudoBin(bytes: Buffer, offset: number) {\n  const lineCount = longToNumber(\n    Long.fromBytesLE(\n      Array.prototype.slice.call(bytes, offset, offset + 8),\n      true,\n    ),\n  )\n  return { lineCount }\n}\n\nexport function findFirstData(\n  firstDataLine: VirtualOffset | undefined,\n  virtualOffset: VirtualOffset,\n) {\n  return firstDataLine\n    ? firstDataLine.compareTo(virtualOffset) > 0\n      ? virtualOffset\n      : firstDataLine\n    : virtualOffset\n}\n\nexport function parseNameBytes(\n  namesBytes: Buffer,\n  renameRefSeq: (arg: string) => string = s => s,\n) {\n  let currRefId = 0\n  let currNameStart = 0\n  const refIdToName = []\n  const refNameToId: Record<string, number> = {}\n  for (let i = 0; i < namesBytes.length; i += 1) {\n    if (!namesBytes[i]) {\n      if (currNameStart < i) {\n        let refName = namesBytes.toString('utf8', currNameStart, i)\n        refName = renameRefSeq(refName)\n        refIdToName[currRefId] = refName\n        refNameToId[refName] = currRefId\n      }\n      currNameStart = i + 1\n      currRefId += 1\n    }\n  }\n  return { refNameToId, refIdToName }\n}\n","import { GenericFilehandle } from 'generic-filehandle'\nimport Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} [renameRefSeqs]\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n}\n","import VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\n\nimport { optimizeChunks, parsePseudoBin, findFirstData, BaseOpts } from './util'\nimport IndexFile from './indexFile'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nfunction reg2bins(beg: number, end: number) {\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ]\n}\n\nexport default class BAI extends IndexFile {\n  public setupP?: ReturnType<BAI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  // fetch and parse the index\n  async _parse(opts?: BaseOpts) {\n    const bytes = (await this.filehandle.readFile(opts)) as Buffer\n\n    // check BAI magic numbers\n    if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    const refCount = bytes.readInt32LE(4)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    let curr = 8\n    let firstDataLine: VirtualOffset | undefined\n\n    type BinIndex = Record<string, Chunk[]>\n    type LinearIndex = VirtualOffset[]\n    const indices = new Array<{\n      binIndex: BinIndex\n      linearIndex: LinearIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      let stats\n\n      curr += 4\n      const binIndex: Record<number, Chunk[]> = {}\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          stats = parsePseudoBin(bytes, curr + 16)\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k++) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = bytes.readInt32LE(curr)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n\n      indices[i] = { binIndex, linearIndex, stats }\n    }\n\n    return {\n      bai: true,\n      firstDataLine,\n      maxBlockSize: 1 << 16,\n      indices,\n      refCount,\n    }\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts: BaseOpts = {},\n  ): Promise<{ start: number; end: number; score: number }[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices[seqId]\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (linearIndex.length === 0) {\n      return []\n    }\n    const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v)\n    const s = start === undefined ? 0 : roundDown(start, v)\n    const depths = range\n      ? new Array((e - s) / v)\n      : new Array(linearIndex.length - 1)\n    const totalSize = linearIndex[linearIndex.length - 1].blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v].blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1].blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1].blockPosition\n    }\n    return depths.map(d => ({\n      ...d,\n      score: (d.score * (stats?.lineCount || 0)) / totalSize,\n    }))\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const binChunk of binChunks) {\n            chunks.push(binChunk)\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest: VirtualOffset | undefined\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n      if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n        lowest = vp\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nconst CRC_TABLE = new Int32Array([\n  0,\n  1996959894,\n  3993919788,\n  2567524794,\n  124634137,\n  1886057615,\n  3915621685,\n  2657392035,\n  249268274,\n  2044508324,\n  3772115230,\n  2547177864,\n  162941995,\n  2125561021,\n  3887607047,\n  2428444049,\n  498536548,\n  1789927666,\n  4089016648,\n  2227061214,\n  450548861,\n  1843258603,\n  4107580753,\n  2211677639,\n  325883990,\n  1684777152,\n  4251122042,\n  2321926636,\n  335633487,\n  1661365465,\n  4195302755,\n  2366115317,\n  997073096,\n  1281953886,\n  3579855332,\n  2724688242,\n  1006888145,\n  1258607687,\n  3524101629,\n  2768942443,\n  901097722,\n  1119000684,\n  3686517206,\n  2898065728,\n  853044451,\n  1172266101,\n  3705015759,\n  2882616665,\n  651767980,\n  1373503546,\n  3369554304,\n  3218104598,\n  565507253,\n  1454621731,\n  3485111705,\n  3099436303,\n  671266974,\n  1594198024,\n  3322730930,\n  2970347812,\n  795835527,\n  1483230225,\n  3244367275,\n  3060149565,\n  1994146192,\n  31158534,\n  2563907772,\n  4023717930,\n  1907459465,\n  112637215,\n  2680153253,\n  3904427059,\n  2013776290,\n  251722036,\n  2517215374,\n  3775830040,\n  2137656763,\n  141376813,\n  2439277719,\n  3865271297,\n  1802195444,\n  476864866,\n  2238001368,\n  4066508878,\n  1812370925,\n  453092731,\n  2181625025,\n  4111451223,\n  1706088902,\n  314042704,\n  2344532202,\n  4240017532,\n  1658658271,\n  366619977,\n  2362670323,\n  4224994405,\n  1303535960,\n  984961486,\n  2747007092,\n  3569037538,\n  1256170817,\n  1037604311,\n  2765210733,\n  3554079995,\n  1131014506,\n  879679996,\n  2909243462,\n  3663771856,\n  1141124467,\n  855842277,\n  2852801631,\n  3708648649,\n  1342533948,\n  654459306,\n  3188396048,\n  3373015174,\n  1466479909,\n  544179635,\n  3110523913,\n  3462522015,\n  1591671054,\n  702138776,\n  2966460450,\n  3352799412,\n  1504918807,\n  783551873,\n  3082640443,\n  3233442989,\n  3988292384,\n  2596254646,\n  62317068,\n  1957810842,\n  3939845945,\n  2647816111,\n  81470997,\n  1943803523,\n  3814918930,\n  2489596804,\n  225274430,\n  2053790376,\n  3826175755,\n  2466906013,\n  167816743,\n  2097651377,\n  4027552580,\n  2265490386,\n  503444072,\n  1762050814,\n  4150417245,\n  2154129355,\n  426522225,\n  1852507879,\n  4275313526,\n  2312317920,\n  282753626,\n  1742555852,\n  4189708143,\n  2394877945,\n  397917763,\n  1622183637,\n  3604390888,\n  2714866558,\n  953729732,\n  1340076626,\n  3518719985,\n  2797360999,\n  1068828381,\n  1219638859,\n  3624741850,\n  2936675148,\n  906185462,\n  1090812512,\n  3747672003,\n  2825379669,\n  829329135,\n  1181335161,\n  3412177804,\n  3160834842,\n  628085408,\n  1382605366,\n  3423369109,\n  3138078467,\n  570562233,\n  1426400815,\n  3317316542,\n  2998733608,\n  733239954,\n  1555261956,\n  3268935591,\n  3050360625,\n  752459403,\n  1541320221,\n  2607071920,\n  3965973030,\n  1969922972,\n  40735498,\n  2617837225,\n  3943577151,\n  1913087877,\n  83908371,\n  2512341634,\n  3803740692,\n  2075208622,\n  213261112,\n  2463272603,\n  3855990285,\n  2094854071,\n  198958881,\n  2262029012,\n  4057260610,\n  1759359992,\n  534414190,\n  2176718541,\n  4139329115,\n  1873836001,\n  414664567,\n  2282248934,\n  4279200368,\n  1711684554,\n  285281116,\n  2405801727,\n  4167216745,\n  1634467795,\n  376229701,\n  2685067896,\n  3608007406,\n  1308918612,\n  956543938,\n  2808555105,\n  3495958263,\n  1231636301,\n  1047427035,\n  2932959818,\n  3654703836,\n  1088359270,\n  936918e3,\n  2847714899,\n  3736837829,\n  1202900863,\n  817233897,\n  3183342108,\n  3401237130,\n  1404277552,\n  615818150,\n  3134207493,\n  3453421203,\n  1423857449,\n  601450431,\n  3009837614,\n  3294710456,\n  1567103746,\n  711928724,\n  3020668471,\n  3272380065,\n  1510334235,\n  755167117\n]);\nfunction ensureBuffer(input) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n  if (typeof input === \"number\") {\n    return Buffer.alloc(input);\n  } else if (typeof input === \"string\") {\n    return Buffer.from(input);\n  } else {\n    throw new Error(\"input must be buffer, number, or string, received \" + typeof input);\n  }\n}\nfunction bufferizeInt(num) {\n  const tmp = ensureBuffer(4);\n  tmp.writeInt32BE(num, 0);\n  return tmp;\n}\nfunction _crc32(buf, previous) {\n  buf = ensureBuffer(buf);\n  if (Buffer.isBuffer(previous)) {\n    previous = previous.readUInt32BE(0);\n  }\n  let crc = ~~previous ^ -1;\n  for (var n = 0; n < buf.length; n++) {\n    crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;\n  }\n  return crc ^ -1;\n}\nfunction crc32() {\n  return bufferizeInt(_crc32.apply(null, arguments));\n}\ncrc32.signed = function() {\n  return _crc32.apply(null, arguments);\n};\ncrc32.unsigned = function() {\n  return _crc32.apply(null, arguments) >>> 0;\n};\nvar bufferCrc32 = crc32;\n\nconst index = /*@__PURE__*/getDefaultExportFromCjs(bufferCrc32);\n\nexport { index as default };\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport {\n  optimizeChunks,\n  findFirstData,\n  parsePseudoBin,\n  parseNameBytes,\n  BaseOpts,\n} from './util'\n\nimport IndexFile from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber = 0\n  private depth = 0\n  private minShift = 0\n\n  public setupP?: ReturnType<CSI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Buffer, offset: number) {\n    const formatFlags = bytes.readInt32LE(offset)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as Record<number, string>\n    )[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    const metaValue = bytes.readInt32LE(offset + 16)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : ''\n    const skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    return {\n      columnNumbers,\n      coordinateType,\n      metaValue,\n      metaChar,\n      skipLines,\n      format,\n      formatFlags,\n      ...parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n        this.renameRefSeq,\n      ),\n    }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const buffer = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buffer)\n\n    let csiVersion\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const auxLength = bytes.readInt32LE(12)\n    const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined\n    const refCount = bytes.readInt32LE(16 + auxLength)\n\n    type BinIndex = Record<string, Chunk[]>\n\n    // read the indexes for each reference sequence\n    let curr = 16 + auxLength + 4\n    let firstDataLine: VirtualOffset | undefined\n    const indices = new Array<{\n      binIndex: BinIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      curr += 4\n      const binIndex: Record<string, Chunk[]> = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j++) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin > this.maxBinNumber) {\n          stats = parsePseudoBin(bytes, curr + 28)\n          curr += 28 + 16\n        } else {\n          firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr))\n          curr += 8\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      indices[i] = { binIndex, stats }\n    }\n\n    return {\n      csiVersion,\n      firstDataLine,\n      indices,\n      refCount,\n      csi: true,\n      maxBlockSize: 1 << 16,\n      ...aux,\n    }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    const ba = indexData?.indices[refId]\n    if (!ba) {\n      return []\n    }\n    const overlappingBins = this.reg2bins(min, max)\n\n    if (overlappingBins.length === 0) {\n      return []\n    }\n\n    const chunks = []\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const c of binChunks) {\n            chunks.push(c)\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end)\n   * (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e])\n    }\n    return bins\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","import Constants from './constants'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\n/**\n * Class of each BAM record returned by this API.\n */\nexport default class BamRecord {\n  private data = {} as Record<string, any>\n  private bytes: { start: number; end: number; byteArray: Buffer }\n  private _id: number\n  private _tagOffset: number | undefined\n  private _tagList: string[] = []\n  private _allTagsParsed = false\n\n  public flags: any\n  public _refID: number\n  constructor(args: any) {\n    const { bytes, fileOffset } = args\n    const { byteArray, start } = bytes\n    this.data = {}\n    this.bytes = bytes\n    this._id = fileOffset\n    this._refID = byteArray.readInt32LE(start + 4)\n    this.data.start = byteArray.readInt32LE(start + 8)\n    this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16\n  }\n\n  get(field: string) {\n    //@ts-ignore\n    if (this[field]) {\n      //@ts-ignore\n      if (this.data[field]) {\n        return this.data[field]\n      }\n      //@ts-ignore\n      this.data[field] = this[field]()\n      return this.data[field]\n    }\n    return this._get(field.toLowerCase())\n  }\n\n  end() {\n    return this.get('start') + this.get('length_on_ref')\n  }\n\n  seq_id() {\n    return this._refID\n  }\n\n  // same as get(), except requires lower-case arguments.  used\n  // internally to save lots of calls to field.toLowerCase()\n  _get(field: string) {\n    if (field in this.data) {\n      return this.data[field]\n    }\n    this.data[field] = this._parseTag(field)\n    return this.data[field]\n  }\n\n  _tags() {\n    this._parseAllTags()\n\n    let tags = ['seq']\n\n    if (!this.isSegmentUnmapped()) {\n      tags.push(\n        'start',\n        'end',\n        'strand',\n        'score',\n        'qual',\n        'MQ',\n        'CIGAR',\n        'length_on_ref',\n        'template_length',\n      )\n    }\n    if (this.isPaired()) {\n      tags.push('next_segment_position', 'pair_orientation')\n    }\n    tags = tags.concat(this._tagList || [])\n\n    for (const k of Object.keys(this.data)) {\n      if (!k.startsWith('_') && k !== 'next_seq_id') {\n        tags.push(k)\n      }\n    }\n\n    const seen: Record<string, boolean> = {}\n    return tags.filter(t => {\n      if (\n        (t in this.data && this.data[t] === undefined) ||\n        t === 'CG' ||\n        t === 'cg'\n      ) {\n        return false\n      }\n\n      const lt = t.toLowerCase()\n      const s = seen[lt]\n      seen[lt] = true\n      return !s\n    })\n  }\n\n  parent() {\n    return\n  }\n\n  children() {\n    return this.get('subfeatures')\n  }\n\n  id() {\n    return this._id\n  }\n\n  // special parsers\n  /**\n   * Mapping quality score.\n   */\n  mq() {\n    const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  score() {\n    return this.get('mq')\n  }\n\n  qual() {\n    return this.qualRaw()?.join(' ')\n  }\n\n  qualRaw() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const { start, byteArray } = this.bytes\n    const p =\n      start +\n      36 +\n      this.get('_l_read_name') +\n      this.get('_n_cigar_op') * 4 +\n      this.get('_seq_bytes')\n    const lseq = this.get('seq_length')\n    return byteArray.subarray(p, p + lseq)\n  }\n\n  strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  multi_segment_next_segment_strand() {\n    if (this.isMateUnmapped()) {\n      return\n    }\n    return this.isMateReverseComplemented() ? -1 : 1\n  }\n\n  name() {\n    return this.get('_read_name')\n  }\n\n  _read_name() {\n    const nl = this.get('_l_read_name')\n    const { byteArray, start } = this.bytes\n    return byteArray.toString('ascii', start + 36, start + 36 + nl - 1)\n  }\n\n  /**\n   * Get the value of a tag, parsing the tags as far as necessary.\n   * Only called if we have not already parsed that field.\n   */\n  _parseTag(tagName?: string) {\n    // if all of the tags have been parsed and we're still being\n    // called, we already know that we have no such tag, because\n    // it would already have been cached.\n    if (this._allTagsParsed) {\n      return\n    }\n\n    const { byteArray, start } = this.bytes\n    let p =\n      this._tagOffset ||\n      start +\n        36 +\n        this.get('_l_read_name') +\n        this.get('_n_cigar_op') * 4 +\n        this.get('_seq_bytes') +\n        this.get('seq_length')\n\n    const blockEnd = this.bytes.end\n    let lcTag\n    while (p < blockEnd && lcTag !== tagName) {\n      const tag = String.fromCharCode(byteArray[p], byteArray[p + 1])\n      lcTag = tag.toLowerCase()\n      const type = String.fromCharCode(byteArray[p + 2])\n      p += 3\n\n      let value\n      switch (type) {\n        case 'A': {\n          value = String.fromCharCode(byteArray[p])\n          p += 1\n          break\n        }\n        case 'i': {\n          value = byteArray.readInt32LE(p)\n          p += 4\n          break\n        }\n        case 'I': {\n          value = byteArray.readUInt32LE(p)\n          p += 4\n          break\n        }\n        case 'c': {\n          value = byteArray.readInt8(p)\n          p += 1\n          break\n        }\n        case 'C': {\n          value = byteArray.readUInt8(p)\n          p += 1\n          break\n        }\n        case 's': {\n          value = byteArray.readInt16LE(p)\n          p += 2\n          break\n        }\n        case 'S': {\n          value = byteArray.readUInt16LE(p)\n          p += 2\n          break\n        }\n        case 'f': {\n          value = byteArray.readFloatLE(p)\n          p += 4\n          break\n        }\n        case 'Z':\n        case 'H': {\n          value = ''\n          while (p <= blockEnd) {\n            const cc = byteArray[p++]\n            if (cc === 0) {\n              break\n            } else {\n              value += String.fromCharCode(cc)\n            }\n          }\n          break\n        }\n        case 'B': {\n          value = ''\n          const cc = byteArray[p++]\n          const Btype = String.fromCharCode(cc)\n          const limit = byteArray.readInt32LE(p)\n          p += 4\n          if (Btype === 'i') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 'I') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readUInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readUInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 's') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'S') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'c') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'C') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'f') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readFloatLE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 4\n            }\n          }\n          break\n        }\n        default: {\n          console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`)\n          value = undefined\n          p = blockEnd\n        } // stop parsing tags\n      }\n\n      this._tagOffset = p\n\n      this._tagList.push(tag)\n      if (lcTag === tagName) {\n        return value\n      }\n\n      this.data[lcTag] = value\n    }\n    this._allTagsParsed = true\n    return\n  }\n\n  _parseAllTags() {\n    this._parseTag('')\n  }\n\n  _parseCigar(cigar: string) {\n    return (\n      //@ts-ignore\n      cigar\n        .match(/\\d+\\D/g)\n        //@ts-ignore\n        .map(op => [op.match(/\\D/)[0].toUpperCase(), Number.parseInt(op, 10)])\n    )\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  cigar() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const { byteArray, start } = this.bytes\n    const numCigarOps = this.get('_n_cigar_op')\n    let p = start + 36 + this.get('_l_read_name')\n    const seqLen = this.get('seq_length')\n    let cigar = ''\n    let lref = 0\n\n    // check for CG tag by inspecting whether the CIGAR field\n    // contains a clip that consumes entire seqLen\n    let cigop = byteArray.readInt32LE(p)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === seqLen) {\n      // if there is a CG the second CIGAR field will\n      // be a N tag the represents the length on ref\n      p += 4\n      cigop = byteArray.readInt32LE(p)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      this.data.length_on_ref = lop\n      return this.get('CG')\n    } else {\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = byteArray.readInt32LE(p)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]\n        cigar += lop + op\n\n        // soft clip, hard clip, and insertion don't count toward\n        // the length on the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      this.data.length_on_ref = lref\n      return cigar\n    }\n  }\n\n  length_on_ref() {\n    if (this.data.length_on_ref) {\n      return this.data.length_on_ref\n    } else {\n      this.get('cigar') // the length_on_ref is set as a side effect\n      return this.data.length_on_ref\n    }\n  }\n\n  _n_cigar_op() {\n    return this.get('_flag_nc') & 0xffff\n  }\n\n  _l_read_name() {\n    return this.get('_bin_mq_nl') & 0xff\n  }\n\n  /**\n   * number of bytes in the sequence field\n   */\n  _seq_bytes() {\n    return (this.get('seq_length') + 1) >> 1\n  }\n\n  getReadBases() {\n    return this.seq()\n  }\n\n  seq() {\n    const { byteArray, start } = this.bytes\n    const p =\n      start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4\n    const seqBytes = this.get('_seq_bytes')\n    const len = this.get('seq_length')\n    let buf = ''\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = byteArray[p + j]\n      buf += SEQRET_DECODER[(sb & 0xf0) >> 4]\n      i++\n      if (i < len) {\n        buf += SEQRET_DECODER[sb & 0x0f]\n        i++\n      }\n    }\n    return buf\n  }\n\n  // adapted from igv.js\n  getPairOrientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      !this.isMateUnmapped() &&\n      this._refID === this._next_refid()\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length()\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return ''\n  }\n\n  _bin_mq_nl() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 12)\n  }\n\n  _flag_nc() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 16)\n  }\n\n  seq_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 20)\n  }\n\n  _next_refid() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 24)\n  }\n\n  _next_pos() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 28)\n  }\n\n  template_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 32)\n  }\n\n  toJSON() {\n    const data: Record<string, any> = {}\n    for (const k of Object.keys(this)) {\n      if (k.startsWith('_') || k === 'bytes') {\n        continue\n      }\n      //@ts-ignore\n      data[k] = this[k]\n    }\n\n    return data\n  }\n}\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  for (const line of lines) {\n    const [tag, ...fields] = line.split(/\\t/)\n    if (tag) {\n      data.push({\n        tag: tag.slice(1),\n        data: fields.map(f => {\n          const r = f.indexOf(':')\n          const fieldTag = f.slice(0, r)\n          const value = f.slice(r + 1)\n          return { tag: fieldTag, value }\n        }),\n      })\n    }\n  }\n  return data\n}\n","import { Buffer } from 'buffer'\nimport crc32 from 'buffer-crc32'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\n\n// locals\nimport BAI from './bai'\nimport CSI from './csi'\nimport Chunk from './chunk'\nimport BAMFeature from './record'\nimport { parseHeaderText } from './sam'\nimport { checkAbortSignal, timeout, makeOpts, BamOpts, BaseOpts } from './util'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\nasync function gen2array<T>(gen: AsyncIterable<T[]>): Promise<T[]> {\n  let out: T[] = []\n  for await (const x of gen) {\n    out = out.concat(x)\n  }\n  return out\n}\n\ninterface Args {\n  chunk: Chunk\n  opts: BaseOpts\n}\n\nclass NullFilehandle {\n  public read(): Promise<any> {\n    throw new Error('never called')\n  }\n  public stat(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public readFile(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public close(): Promise<any> {\n    throw new Error('never called')\n  }\n}\nexport default class BamFile {\n  public renameRefSeq: (a: string) => string\n  public bam: GenericFilehandle\n  public header?: string\n  public chrToIndex?: Record<string, number>\n  public indexToChr?: { refName: string; length: number }[]\n  public yieldThreadTime: number\n  public index?: BAI | CSI\n  public htsget = false\n  public headerP?: ReturnType<BamFile['getHeaderPre']>\n\n  private featureCache = new AbortablePromiseCache<Args, BAMFeature[]>({\n    cache: new QuickLRU({\n      maxSize: 50,\n    }),\n    fill: async (args: Args, signal) => {\n      const { chunk, opts } = args\n      const { data, cpositions, dpositions } = await this._readChunk({\n        chunk,\n        opts: { ...opts, signal },\n      })\n      return this.readBamFeatures(data, cpositions, dpositions, chunk)\n    },\n  })\n\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    htsget,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n    htsget?: boolean\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else if (htsget) {\n      this.htsget = true\n      this.bam = new NullFilehandle()\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else if (htsget) {\n      this.htsget = true\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeaderPre(origOpts?: BaseOpts) {\n    const opts = makeOpts(origOpts)\n    if (!this.index) {\n      return\n    }\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine\n      ? indexData.firstDataLine.blockPosition + 65535\n      : undefined\n    let buffer\n    if (ret) {\n      const s = ret + blockLen\n      const res = await this.bam.read(Buffer.alloc(s), 0, s, 0, opts)\n      if (!res.bytesRead) {\n        throw new Error('Error reading header')\n      }\n      buffer = res.buffer.subarray(0, Math.min(res.bytesRead, ret))\n    } else {\n      buffer = await this.bam.readFile(opts)\n    }\n\n    const uncba = await unzip(buffer)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    this.header = uncba.toString('utf8', 8, 8 + headLen)\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(\n      headLen + 8,\n      65535,\n      opts,\n    )\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  getHeader(opts?: BaseOpts) {\n    if (!this.headerP) {\n      this.headerP = this.getHeaderPre(opts).catch(e => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs\n  // a chunk and doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts?: BaseOpts,\n  ): Promise<{\n    chrToIndex: Record<string, number>\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    const size = refSeqBytes + blockLen\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      refSeqBytes,\n      0,\n      opts,\n    )\n    if (!bytesRead) {\n      throw new Error('Error reading refseqs from header')\n    }\n    const uncba = await unzip(\n      buffer.subarray(0, Math.min(bytesRead, refSeqBytes)),\n    )\n    const nRef = uncba.readInt32LE(start)\n    let p = start + 4\n    const chrToIndex: Record<string, number> = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    for (let i = 0; i < nRef; i += 1) {\n      const lName = uncba.readInt32LE(p)\n      const refName = this.renameRefSeq(\n        uncba.toString('utf8', p + 4, p + 4 + lName - 1),\n      )\n      const lRef = uncba.readInt32LE(p + lName + 4)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(\n          `BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`,\n        )\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    return gen2array(this.streamRecordsForRange(chr, min, max, opts))\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    await this.getHeader(opts)\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined || !this.index) {\n      yield []\n    } else {\n      const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n      yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n    }\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { viewAsPairs } = opts\n    const feats = [] as BAMFeature[][]\n    let done = false\n\n    for (const chunk of chunks) {\n      const records = await this.featureCache.get(\n        chunk.toString(),\n        { chunk, opts },\n        opts.signal,\n      )\n\n      const recs = [] as BAMFeature[]\n      for (const feature of records) {\n        if (feature.seq_id() === chrId) {\n          if (feature.get('start') >= max) {\n            // past end of range, can stop iterating\n            done = true\n            break\n          } else if (feature.get('end') >= min) {\n            // must be in range\n            recs.push(feature)\n          }\n        }\n      }\n      feats.push(recs)\n      yield recs\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n    if (viewAsPairs) {\n      yield this.fetchPairs(chrId, feats, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, feats: BAMFeature[][], opts: BamOpts) {\n    const { pairAcrossChr, maxInsertSize = 200000 } = opts\n    const unmatedPairs: Record<string, boolean> = {}\n    const readIds: Record<string, number> = {}\n    feats.map(ret => {\n      const readNames: Record<string, number> = {}\n      for (const element of ret) {\n        const name = element.name()\n        const id = element.id()\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name]++\n        readIds[id] = 1\n      }\n      for (const [k, v] of Object.entries(readNames)) {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      }\n    })\n\n    const matePromises: Promise<Chunk[]>[] = []\n    feats.map(ret => {\n      for (const f of ret) {\n        const name = f.name()\n        const start = f.get('start')\n        const pnext = f._next_pos()\n        const rnext = f._next_refid()\n        if (\n          this.index &&\n          unmatedPairs[name] &&\n          (pairAcrossChr ||\n            (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))\n        ) {\n          matePromises.push(\n            this.index.blocksForRange(rnext, pnext, pnext + 1, opts),\n          )\n        }\n      }\n    })\n\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n    // concatenated, then filter dup chunks)\n    const map = new Map<string, Chunk>()\n    const res = await Promise.all(matePromises)\n    for (const m of res.flat()) {\n      if (!map.has(m.toString())) {\n        map.set(m.toString(), m)\n      }\n    }\n\n    const mateFeatPromises = await Promise.all(\n      [...map.values()].map(async c => {\n        const { data, cpositions, dpositions, chunk } = await this._readChunk({\n          chunk: c,\n          opts,\n        })\n        const mateRecs = [] as BAMFeature[]\n        for (const feature of await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )) {\n          if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {\n            mateRecs.push(feature)\n          }\n        }\n        return mateRecs\n      }),\n    )\n    return mateFeatPromises.flat()\n  }\n\n  async _readRegion(position: number, size: number, opts: BaseOpts = {}) {\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      size,\n      position,\n      opts,\n    )\n\n    return buffer.subarray(0, Math.min(bytesRead, size))\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const buffer = await this._readRegion(\n      chunk.minv.blockPosition,\n      chunk.fetchedSize(),\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(buffer, chunk)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Buffer,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = [] as BAMFeature[]\n    let pos = 0\n    let last = +Date.now()\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = ba.readInt32LE(blockStart)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based\n          // ID if the info for that is available, otherwise crc32 of the\n          // features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block\n          // boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a\n          // \"unique\" address space so that data in that block could never\n          // overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied\n          // by (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it\n          // blockStart starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not\n          // realistically happen\n          fileOffset:\n            cpositions.length > 0\n              ? cpositions[pos] * (1 << 8) +\n                (blockStart - dpositions[pos]) +\n                chunk.minv.dataPosition +\n                1\n              : // must be slice, not subarray for buffer polyfill on web\n                crc32.signed(ba.slice(blockStart, blockEnd)),\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? false : this.index?.hasRefSeq(seqId)\n  }\n\n  async lineCount(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? [] : this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined\n      ? []\n      : this.index.blocksForRange(seqId, start, end, opts)\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport { Buffer } from 'buffer'\nimport { BaseOpts, BamOpts } from './util'\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport Chunk from './chunk'\nimport { parseHeaderText } from './sam'\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: HtsgetChunk[], opts?: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async chunk => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        return Buffer.from(url.split(',')[1], 'base64')\n      } else {\n        //remove referer header, it is not even allowed to be specified\n        // @ts-expect-error\n\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts?.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(\n            `HTTP ${res.status} fetching ${url}: ${await res.text()}`,\n          )\n        }\n        return Buffer.from(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return Buffer.concat(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    super({ htsget: true })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined) {\n      yield []\n    } else {\n      const result = await fetch(url, { ...opts })\n      if (!result.ok) {\n        throw new Error(\n          `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n        )\n      }\n      const data = await result.json()\n      const uncba = await concat(data.htsget.urls.slice(1), opts)\n\n      yield* this._fetchChunkFeatures(\n        [\n          // fake stuff to pretend to be a Chunk\n          {\n            buffer: uncba,\n            _fetchedSize: undefined,\n            bin: 0,\n            compareTo() {\n              return 0\n            },\n            toUniqueString() {\n              return `${chr}_${min}_${max}`\n            },\n            fetchedSize() {\n              return 0\n            },\n            minv: {\n              dataPosition: 0,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            maxv: {\n              dataPosition: Number.MAX_SAFE_INTEGER,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            toString() {\n              return `${chr}_${min}_${max}`\n            },\n          },\n        ],\n        chrId,\n        min,\n        max,\n        opts,\n      )\n    }\n  }\n\n  async _readChunk({ chunk }: { chunk: Chunk; opts: BaseOpts }) {\n    if (!chunk.buffer) {\n      throw new Error('expected chunk.buffer in htsget')\n    }\n    return { data: chunk.buffer, cpositions: [], dpositions: [], chunk }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n    const headerText = uncba.toString('utf8', 8, 8 + headLen)\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: { refName: string; length: number }[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter(l => l.tag === 'SQ')\n    for (const [refId, sqLine] of sqLines.entries()) {\n      let refName = ''\n      let length = 0\n      for (const item of sqLine.data) {\n        if (item.tag === 'SN') {\n          refName = item.value\n        } else if (item.tag === 'LN') {\n          length = +item.value\n        }\n      }\n      nameToId[refName] = refId\n      idToName[refId] = { refName, length }\n    }\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","// locals\nimport { getClip, getMismatches } from '../MismatchParser';\nexport default class BamSlightlyLazyFeature {\n    // uses parameter properties to automatically create fields on the class\n    // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n    constructor(record, adapter, ref) {\n        this.record = record;\n        this.adapter = adapter;\n        this.ref = ref;\n    }\n    _get_name() {\n        return this.record.get('name');\n    }\n    _get_type() {\n        return 'match';\n    }\n    _get_score() {\n        return this.record.get('mq');\n    }\n    _get_flags() {\n        return this.record.flags;\n    }\n    _get_strand() {\n        return this.record.isReverseComplemented() ? -1 : 1;\n    }\n    _get_pair_orientation() {\n        return this.record.isPaired() ? this.record.getPairOrientation() : undefined;\n    }\n    _get_next_ref() {\n        return this.record.isPaired()\n            ? this.adapter.refIdToName(this.record._next_refid())\n            : undefined;\n    }\n    _get_next_pos() {\n        return this.record.isPaired() ? this.record._next_pos() : undefined;\n    }\n    _get_next_segment_position() {\n        return this.record.isPaired()\n            ? `${this.adapter.refIdToName(this.record._next_refid())}:${this.record._next_pos() + 1}`\n            : undefined;\n    }\n    _get_seq() {\n        return this.record.getReadBases();\n    }\n    qualRaw() {\n        return this.record.qualRaw();\n    }\n    set() { }\n    tags() {\n        const properties = Object.getOwnPropertyNames(BamSlightlyLazyFeature.prototype);\n        return [\n            ...new Set(properties\n                .filter(prop => prop.startsWith('_get_') &&\n                prop !== '_get_mismatches' &&\n                prop !== '_get_tags')\n                .map(methodName => methodName.replace('_get_', ''))\n                .concat(this.record._tags())),\n        ];\n    }\n    id() {\n        return `${this.adapter.id}-${this.record.id()}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(field) {\n        const methodName = `_get_${field}`;\n        // @ts-expect-error\n        if (this[methodName]) {\n            // @ts-expect-error\n            return this[methodName]();\n        }\n        return this.record.get(field);\n    }\n    _get_refName() {\n        return this.adapter.refIdToName(this.record.seq_id());\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    pairedFeature() {\n        return false;\n    }\n    toJSON() {\n        return {\n            ...Object.fromEntries(this.tags()\n                .map(t => [t, this.get(t)])\n                .filter(elt => elt[1] !== undefined)),\n            uniqueId: this.id(),\n        };\n    }\n    _get_mismatches() {\n        return getMismatches(this.get('CIGAR'), this.get('MD'), this.get('seq'), this.ref, this.qualRaw());\n    }\n    _get_clipPos() {\n        const cigar = this.get('CIGAR') || '';\n        return getClip(cigar, this.get('strand'));\n    }\n}\n","import { BamFile } from '@gmod/bam';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { bytesForRegions, updateStatus } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\n// locals\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature';\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n    // derived classes may not use the same configuration so a custom\n    // configure method allows derived classes to override this behavior\n    async configurePre() {\n        const bamLocation = this.getConf('bamLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const pm = this.pluginManager;\n        const csi = indexType === 'CSI';\n        const bam = new BamFile({\n            bamFilehandle: openLocation(bamLocation, pm),\n            csiFilehandle: csi ? openLocation(location, pm) : undefined,\n            baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n            // chunkSizeLimit and fetchSizeLimit are more troublesome than\n            // helpful, and have given overly large values on the ultra long\n            // nanopore reads even with 500MB limits, so disabled with infinity\n            yieldThreadTime: Infinity,\n        });\n        const adapterConfig = this.getConf('sequenceAdapter');\n        if (adapterConfig && this.getSubAdapter) {\n            const { dataAdapter } = await this.getSubAdapter(adapterConfig);\n            return {\n                bam,\n                sequenceAdapter: dataAdapter,\n            };\n        }\n        else {\n            return { bam };\n        }\n    }\n    async configure() {\n        if (!this.configureP) {\n            this.configureP = this.configurePre().catch(e => {\n                this.configureP = undefined;\n                throw e;\n            });\n        }\n        return this.configureP;\n    }\n    async getHeader(opts) {\n        const { bam } = await this.configure();\n        return bam.getHeaderText(opts);\n    }\n    async setupPre(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const { bam } = await this.configure();\n        this.samHeader = await updateStatus('Downloading index', statusCallback, async () => {\n            const samHeader = await bam.getHeader(opts);\n            // use the @SQ lines in the header to figure out the\n            // mapping between ref ref ID numbers and names\n            const idToName = [];\n            const nameToId = {};\n            samHeader === null || samHeader === void 0 ? void 0 : samHeader.filter(l => l.tag === 'SQ').forEach((sqLine, refId) => {\n                const SN = sqLine.data.find(item => item.tag === 'SN');\n                if (SN) {\n                    // this is the ref name\n                    const refName = SN.value;\n                    nameToId[refName] = refId;\n                    idToName[refId] = refName;\n                }\n            });\n            return { idToName, nameToId };\n        });\n        return this.samHeader;\n    }\n    async setup(opts) {\n        if (!this.setupP) {\n            this.setupP = this.setupPre(opts).catch(e => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames(opts) {\n        const { idToName } = await this.setup(opts);\n        return idToName;\n    }\n    async seqFetch(refName, start, end) {\n        const { sequenceAdapter } = await this.configure();\n        const refSeqStore = sequenceAdapter;\n        if (!refSeqStore) {\n            return undefined;\n        }\n        if (!refName) {\n            return undefined;\n        }\n        const features = refSeqStore.getFeatures({\n            refName,\n            start,\n            end,\n            assemblyName: '',\n        });\n        const seqChunks = await firstValueFrom(features.pipe(toArray()));\n        let sequence = '';\n        seqChunks\n            .sort((a, b) => a.get('start') - b.get('start'))\n            .forEach(chunk => {\n            const chunkStart = chunk.get('start');\n            const chunkEnd = chunk.get('end');\n            const trimStart = Math.max(start - chunkStart, 0);\n            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);\n            const trimLength = trimEnd - trimStart;\n            const chunkSeq = chunk.get('seq') || chunk.get('residues');\n            sequence += chunkSeq.slice(trimStart, trimStart + trimLength);\n        });\n        if (sequence.length !== end - start) {\n            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);\n        }\n        return sequence;\n    }\n    getFeatures(region, opts) {\n        const { refName, start, end, originalRefName } = region;\n        const { signal, filterBy, statusCallback = () => { } } = opts || {};\n        return ObservableCreate(async (observer) => {\n            const { bam } = await this.configure();\n            await this.setup(opts);\n            const records = await updateStatus('Downloading alignments', statusCallback, () => bam.getRecordsForRange(refName, start, end, opts));\n            await updateStatus('Processing alignments', statusCallback, async () => {\n                const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};\n                for (const record of records) {\n                    let ref;\n                    if (!record.get('MD')) {\n                        ref = await this.seqFetch(originalRefName || refName, record.get('start'), record.get('end'));\n                    }\n                    const flags = record.flags;\n                    if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n                        continue;\n                    }\n                    if (tagFilter) {\n                        const v = record.get(tagFilter.tag);\n                        if (!(tagFilter.value === '*'\n                            ? v !== undefined\n                            : `${v}` === tagFilter.value)) {\n                            continue;\n                        }\n                    }\n                    if (readName && record.get('name') !== readName) {\n                        continue;\n                    }\n                    observer.next(new BamSlightlyLazyFeature(record, this, ref));\n                }\n                observer.complete();\n            });\n        }, signal);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { bam } = await this.configure();\n        // this is a method to avoid calling on htsget adapters\n        if (bam.index) {\n            const bytes = await bytesForRegions(regions, bam);\n            const fetchSizeLimit = this.getConf('fetchSizeLimit');\n            return { bytes, fetchSizeLimit };\n        }\n        else {\n            return super.getMultiRegionFeatureDensityStats(regions, opts);\n        }\n    }\n    freeResources( /* { region } */) { }\n    // depends on setup being called before the BAM constructor\n    refIdToName(refId) {\n        var _a;\n        return (_a = this.samHeader) === null || _a === void 0 ? void 0 : _a.idToName[refId];\n    }\n}\n"],"names":["VirtualOffset","constructor","blockPosition","dataPosition","this","toString","concat","compareTo","b","min","i","_len","arguments","length","args","Array","_key","fromBytes","bytes","offset","undefined","Error","Chunk","minv","maxv","bin","_fetchedSize","toUniqueString","fetchedSize","timeout","ms","Promise","resolve","setTimeout","checkAbortSignal","signal","aborted","DOMException","e","code","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","sort","c0","c1","dif","chunk","push","chunk1","chunk2","parsePseudoBin","lineCount","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","longToNumber","Long","prototype","slice","call","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","renameRefSeq","s","currRefId","currNameStart","refIdToName","refNameToId","refName","IndexFile","_ref","filehandle","n","BAI","refId","opts","_b","_a","parse","indices","stats","_parse","readFile","readUInt32LE","refCount","readInt32LE","curr","binCount","binIndex","j","binLimit","chunkCount","k","u","v","linearCount","linearIndex","bai","maxBlockSize","indexCov","seqId","start","end","range","seqIdx","multiple","roundDown","depths","totalSize","currentPos","score","map","d","blocksForRange","max","indexData","ba","overlappingBins","beg","binChunks","binChunk","nintv","minLin","Math","maxLin","vp","setupP","catch","hasRefSeq","getDefaultExportFromCjs","x","__esModule","Object","hasOwnProperty","CRC_TABLE","Int32Array","ensureBuffer","input","Buffer","isBuffer","alloc","from","_crc32","buf","previous","readUInt32BE","crc","crc32","num","tmp","writeInt32BE","bufferizeInt","apply","signed","unsigned","index","rshift","bits","floor","CSI","maxBinNumber","depth","minShift","parseAuxData","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","String","fromCharCode","skipLines","nameSectionLength","subarray","buffer","unzip","csiVersion","auxLength","aux","csi","reg2bins","c","l","t","bins","SEQRET_DECODER","split","CIGAR_DECODER","BamRecord","data","_tagList","_allTagsParsed","fileOffset","byteArray","_id","_refID","flags","get","field","_get","toLowerCase","seq_id","_parseTag","_tags","_parseAllTags","tags","isSegmentUnmapped","isPaired","keys","startsWith","seen","filter","lt","parent","children","id","mq","qual","qualRaw","join","p","lseq","strand","isReverseComplemented","multi_segment_next_segment_strand","isMateUnmapped","isMateReverseComplemented","name","_read_name","nl","tagName","_tagOffset","blockEnd","lcTag","tag","type","value","readInt8","readUInt8","readInt16LE","readUInt16LE","readFloatLE","cc","Btype","limit","cigop","console","warn","_parseCigar","cigar","match","op","toUpperCase","parseInt","Constants","isProperlyPaired","isRead1","isRead2","isSecondary","isFailedQc","isDuplicate","isSupplementary","numCigarOps","seqLen","lref","lop","length_on_ref","_n_cigar_op","_l_read_name","_seq_bytes","getReadBases","seq","seqBytes","len","sb","getPairOrientation","_next_refid","s1","s2","o1","o2","template_length","_bin_mq_nl","_flag_nc","seq_length","_next_pos","toJSON","parseHeaderText","text","lines","line","fields","f","r","indexOf","BAM_MAGIC","NullFilehandle","read","stat","close","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","yieldThreadTime","renameRefSeqs","featureCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","async","cpositions","dpositions","_readChunk","readBamFeatures","bam","LocalFile","RemoteFile","getHeaderPre","origOpts","obj","makeOpts","ret","res","bytesRead","uncba","headLen","header","chrToIndex","indexToChr","_readRefSeqs","getHeader","headerP","getHeaderText","refSeqBytes","size","nRef","lName","lRef","getRecordsForRange","chr","gen","out","gen2array","streamRecordsForRange","chrId","_fetchChunkFeatures","_this","viewAsPairs","feats","done","records","recs","feature","fetchPairs","reject","pairAcrossChr","maxInsertSize","unmatedPairs","readIds","readNames","element","entries","matePromises","pnext","rnext","abs","Map","all","m","flat","has","set","values","mateRecs","_readRegion","position","_ref2","unzipChunkSlice","blockStart","sink","pos","last","Date","now","BAMFeature","seqName","arr","url","headers","referer","rest","fetch","ok","status","arrayBuffer","elt","HtsgetFile","super","baseUrl","trackId","base","result","json","urls","samHeader","idToName","nameToId","sqLines","sqLine","item","BamSlightlyLazyFeature","record","adapter","_get_name","_get_type","_get_score","_get_flags","_get_strand","_get_pair_orientation","_get_next_ref","_get_next_pos","_get_next_segment_position","_get_seq","properties","getOwnPropertyNames","Set","prop","methodName","replace","_get_refName","pairedFeature","fromEntries","uniqueId","_get_mismatches","getMismatches","_get_clipPos","getClip","BamAdapter","BaseFeatureDataAdapter","configurePre","bamLocation","getConf","location","indexType","pm","pluginManager","openLocation","Infinity","adapterConfig","getSubAdapter","dataAdapter","sequenceAdapter","configure","configureP","setupPre","statusCallback","updateStatus","forEach","SN","find","setup","getRefNames","seqFetch","features","getFeatures","assemblyName","seqChunks","firstValueFrom","pipe","toArray","sequence","a","chunkStart","chunkEnd","trimStart","trimLength","chunkSeq","toLocaleString","region","originalRefName","filterBy","ObservableCreate","flagInclude","flagExclude","tagFilter","readName","observer","next","complete","getMultiRegionFeatureDensityStats","regions","bytesForRegions","fetchSizeLimit","freeResources"],"sourceRoot":""}