{"version":3,"file":"static/js/9985.45436848.chunk.js","mappings":"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","sources":["../node_modules/@jbrowse/plugin-alignments/esm/LinearReadArcsDisplay/drawFeats.js","../node_modules/@jbrowse/plugin-alignments/esm/shared/util.js"],"sourcesContent":["import { getContainingView, getSession } from '@jbrowse/core/util';\n// locals\nimport { getPairedOrientationColor, getPairedInsertSizeColor, getPairedInsertSizeAndOrientationColor, } from '../shared/color';\nimport { featurizeSA } from '../MismatchParser';\nimport { hasPairedReads } from '../shared/util';\nfunction jitter(n) {\n    return Math.random() * 2 * n - n;\n}\nfunction drawLineAtOffset(ctx, offset, height, color) {\n    // draws a vertical line off to middle of nowhere if the second end not found\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(offset, 0);\n    ctx.lineTo(offset, height);\n    ctx.stroke();\n}\nexport function drawFeats(self, ctx, width, height) {\n    const { chainData, colorBy, drawInter, drawLongRange, lineWidthSetting, jitterVal, } = self;\n    if (!chainData) {\n        return;\n    }\n    const view = getContainingView(self);\n    const { assemblyManager } = getSession(self);\n    const { chains, stats } = chainData;\n    const hasPaired = hasPairedReads(chainData);\n    const asm = assemblyManager.get(view.assemblyNames[0]);\n    const type = (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) || 'insertSizeAndOrientation';\n    if (!asm) {\n        return;\n    }\n    ctx.lineWidth = lineWidthSetting;\n    function draw(k1, k2, assembly, longRange) {\n        var _a, _b, _c;\n        const s1 = k1.strand;\n        const s2 = k2.strand;\n        const f1 = s1 === -1;\n        const f2 = s2 === -1;\n        const p1 = f1 ? k1.start : k1.end;\n        const p2 = hasPaired ? (f2 ? k2.start : k2.end) : f2 ? k2.end : k2.start;\n        const ra1 = assembly.getCanonicalRefName(k1.refName) || k1.refName;\n        const ra2 = assembly.getCanonicalRefName(k2.refName) || k2.refName;\n        const r1 = (_a = view.bpToPx({ refName: ra1, coord: p1 })) === null || _a === void 0 ? void 0 : _a.offsetPx;\n        const r2 = (_b = view.bpToPx({ refName: ra2, coord: p2 })) === null || _b === void 0 ? void 0 : _b.offsetPx;\n        if (r1 !== undefined && r2 !== undefined) {\n            const radius = (r2 - r1) / 2;\n            const absrad = Math.abs(radius);\n            const p = r1 - view.offsetPx;\n            const p2 = r2 - view.offsetPx;\n            const drawArcInsteadOfBezier = absrad > 10000;\n            // bezier (used for non-long-range arcs) requires moveTo before beginPath\n            // arc (used for long-range) requires moveTo after beginPath (or else a\n            // unwanted line at y=0 is rendered along with the arc)\n            if (longRange && drawArcInsteadOfBezier) {\n                ctx.moveTo(p, 0);\n                ctx.beginPath();\n            }\n            else {\n                ctx.beginPath();\n                ctx.moveTo(p, 0);\n            }\n            if (longRange && drawArcInsteadOfBezier) {\n                ctx.strokeStyle = 'red';\n            }\n            else {\n                if (hasPaired) {\n                    if (type === 'insertSizeAndOrientation') {\n                        ctx.strokeStyle = getPairedInsertSizeAndOrientationColor(k1, k2, stats)[0];\n                    }\n                    else if (type === 'orientation') {\n                        ctx.strokeStyle = getPairedOrientationColor(k1)[0];\n                    }\n                    else if (type === 'insertSize') {\n                        ctx.strokeStyle =\n                            ((_c = getPairedInsertSizeColor(k1, k2, stats)) === null || _c === void 0 ? void 0 : _c[0]) || 'grey';\n                    }\n                    else if (type === 'gradient') {\n                        ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`;\n                    }\n                }\n                else {\n                    if (type === 'orientation' || type === 'insertSizeAndOrientation') {\n                        if (s1 === -1 && s2 === 1) {\n                            ctx.strokeStyle = 'navy';\n                        }\n                        else if (s1 === 1 && s2 === -1) {\n                            ctx.strokeStyle = 'green';\n                        }\n                        else {\n                            ctx.strokeStyle = 'grey';\n                        }\n                    }\n                    else if (type === 'gradient') {\n                        ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`;\n                    }\n                }\n            }\n            const destX = p + radius * 2;\n            const destY = Math.min(height + jitter(jitterVal), absrad);\n            if (longRange) {\n                // avoid drawing gigantic circles that glitch out the rendering,\n                // instead draw vertical lines\n                if (absrad > 100000) {\n                    drawLineAtOffset(ctx, p + jitter(jitterVal), height, 'red');\n                    drawLineAtOffset(ctx, p2 + jitter(jitterVal), height, 'red');\n                }\n                else if (drawArcInsteadOfBezier) {\n                    ctx.arc(p + radius + jitter(jitterVal), 0, absrad, 0, Math.PI);\n                    ctx.stroke();\n                }\n                else {\n                    ctx.bezierCurveTo(p + jitter(jitterVal), destY, destX, destY, destX + jitter(jitterVal), 0);\n                    ctx.stroke();\n                }\n            }\n            else {\n                ctx.bezierCurveTo(p + jitter(jitterVal), destY, destX, destY, destX + jitter(jitterVal), 0);\n                ctx.stroke();\n            }\n        }\n        else if (r1 && drawInter) {\n            drawLineAtOffset(ctx, r1 - view.offsetPx, height, 'purple');\n        }\n    }\n    for (const chain of chains) {\n        // chain.length === 1, singleton (other pairs/mates not in view)\n        if (chain.length === 1 && drawLongRange) {\n            const f = chain[0];\n            if (hasPaired && !(f.flags & 8)) {\n                const mate = {\n                    refName: f.next_ref || '',\n                    start: f.next_pos || 0,\n                    end: f.next_pos || 0,\n                    strand: f.strand,\n                };\n                draw(f, mate, asm, true);\n            }\n            else {\n                const features = [f, ...featurizeSA(f.SA, f.id, f.strand, f.name)].sort((a, b) => a.clipPos - b.clipPos);\n                for (let i = 0; i < features.length - 1; i++) {\n                    const f = features[i];\n                    const v1 = features[i + 1];\n                    draw(f, v1, asm, true);\n                }\n            }\n        }\n        else {\n            const res = hasPaired\n                ? chain.filter(f => !(f.flags & 2048) && !(f.flags & 8))\n                : chain\n                    .sort((a, b) => a.clipPos - b.clipPos)\n                    .filter(f => !(f.flags & 256));\n            for (let i = 0; i < res.length - 1; i++) {\n                draw(res[i], res[i + 1], asm, false);\n            }\n        }\n    }\n}\n","export function hasPairedReads(features) {\n    for (const f of features.chains.values()) {\n        if (f[0].flags & 1) {\n            return true;\n        }\n    }\n    return false;\n}\n"],"names":["jitter","n","Math","random","drawLineAtOffset","ctx","offset","height","color","strokeStyle","beginPath","moveTo","lineTo","stroke","drawFeats","self","width","chainData","colorBy","drawInter","drawLongRange","lineWidthSetting","jitterVal","view","getContainingView","assemblyManager","getSession","chains","stats","hasPaired","hasPairedReads","asm","get","assemblyNames","type","lineWidth","chain","length","f","flags","features","featurizeSA","SA","id","strand","name","sort","a","b","clipPos","i","draw","refName","next_ref","start","next_pos","end","res","filter","k1","k2","assembly","longRange","_a","_b","_c","s1","s2","f2","p1","p2","ra1","getCanonicalRefName","ra2","r1","bpToPx","coord","offsetPx","r2","undefined","radius","absrad","abs","p","drawArcInsteadOfBezier","getPairedInsertSizeAndOrientationColor","getPairedOrientationColor","getPairedInsertSizeColor","concat","log10","destX","destY","min","arc","PI","bezierCurveTo","values"],"sourceRoot":""}