(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[8545],{92172:(t,e,s)=>{"use strict";s.r(e),s.d(e,{default:()=>v});var a=s(74080),r=s(52631),i=s.n(r),n=s(91205),o=s.n(n);async function h(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{defaultContent:a={}}=s;let r;try{return r=await e(t,{encoding:"utf8"}),JSON.parse(r)}catch(i){if("ENOENT"===i.code||404===i.status)return a;throw i}}class c{constructor(t){let{readFile:e,cacheSize:s=100}=t;if(this.topList=[],this.chunkCache=new(o())({cache:new(i())({maxSize:s}),fill:this.readChunkItems.bind(this)}),this.readFile=e,!this.readFile)throw new Error('must provide a "readFile" function')}importExisting(t,e,s,a,r){this.topList=t,this.attrs=e,this.start=e.makeFastGetter("Start"),this.end=e.makeFastGetter("End"),this.lazyClass=r,this.baseURL=s,this.lazyUrlTemplate=a}binarySearch(t,e,s){let a,r=-1,i=t.length;for(;i-r>1;)a=r+i>>>1,s(t[a])>=e?i=a:r=a;return s===this.end?i:r}readChunkItems(t){return h(a.resolve(this.baseURL,this.lazyUrlTemplate.replace(/\{Chunk\}/gi,t)),this.readFile,{defaultContent:[]})}async*iterateSublist(t,e,s,a,r,i,n){const o=this.attrs.makeGetter("Chunk"),h=this.attrs.makeGetter("Sublist"),c=[];for(let l=this.binarySearch(t,e,r);l<t.length&&l>=0&&a*i(t[l])<a*s;l+=a){if(t[l][0]===this.lazyClass){const e=o(t[l]),s=this.chunkCache.get(e,e).then((t=>[t,e]));c.push(s)}else yield[t[l],n.concat(l)];const u=h(t[l]);u&&(yield*this.iterateSublist(u,e,s,a,r,i,n.concat(l)))}for(let l=0;l<c.length;l+=1){const[t,o]=await c[l];t&&(yield*this.iterateSublist(t,e,s,a,r,i,[...n,o]))}}async*iterate(t,e){const s=t>e?-1:1,a=t>e?this.start:this.end,r=t>e?this.end:this.start;this.topList.length>0&&(yield*this.iterateSublist(this.topList,t,e,s,a,r,[0]))}async histogram(t,e,s){const a=new Array(s);a.fill(0);const r=(e-t)/s;for await(const i of this.iterate(t,e)){const e=Math.max(0,(this.start(i)-t)/r|0),n=Math.min(s,(this.end(i)-t)/r|0);for(let t=e;t<=n;t+=1)a[t]+=1}return a}}const l=class{constructor(t){this.classes=t,this.fields=[];for(let e=0;e<t.length;e+=1){this.fields[e]={};for(let s=0;s<t[e].attributes.length;s+=1)this.fields[e][t[e].attributes[s]]=s+1;void 0===t[e].proto&&(t[e].proto={}),void 0===t[e].isArrayAttr&&(t[e].isArrayAttr={})}}attrIndices(t){return this.classes.map((e=>e.attributes.indexOf(t)+1||e.attributes.indexOf(t.toLowerCase())+1||void 0))}get(t,e){if(e in this.fields[t[0]])return t[this.fields[t[0]][e]];const s=e.toLowerCase();if(s in this.fields[t[0]])return t[this.fields[t[0]][s]];const a=this.classes[t[0]].attributes.length+1;return a>=t.length||!(e in t[a])?e in this.classes[t[0]].proto?this.classes[t[0]].proto[e]:void 0:t[a][e]}makeSetter(t){return(e,s)=>{this.set(e,t,s)}}makeGetter(t){return e=>this.get(e,t)}makeFastGetter(t){const e=this.attrIndices(t);return function(t){if(void 0!==e[t[0]])return t[e[t[0]]]}}accessors(){return this._accessors||(this._accessors=this._makeAccessors()),this._accessors}_makeAccessors(){const t={},e={get(t){const e=this.get.field_accessors[t.toLowerCase()];if(e)return e.call(this)},set(t,e){const s=this.set.field_accessors[t];if(s)return s.call(this,e)},tags(){return s[this[0]]||[]}};e.get.field_accessors={},e.set.field_accessors={},this.classes.forEach(((e,s)=>{(e.attributes||[]).forEach(((e,a)=>{t[e]=t[e]||[],t[e][s]=a+1,e=e.toLowerCase(),t[e]=t[e]||[],t[e][s]=a+1}))}));const s=this.classes.map((t=>t.attributes));return Object.keys(t).forEach((s=>{const a=t[s];e.get.field_accessors[s]=a?function(){return this[a[this[0]]]}:function(){}})),e}};class u{constructor(t,e){let{urlTemplate:s,chunkSize:a,length:r,cacheSize:n=100,readFile:h}=t;if(this.urlTemplate=s,this.chunkSize=a,this.length=r,this.baseUrl=void 0===e?"":e,this.readFile=h,!h)throw new Error("must provide readFile callback");this.chunkCache=new(o())({cache:new(i())({maxSize:n}),fill:this.getChunk.bind(this)})}index(t,e,s){this.range(t,t,e,void 0,s)}async*range(t,e){t=Math.max(0,t),e=Math.min(e,this.length-1);const s=Math.floor(t/this.chunkSize),a=Math.floor(e/this.chunkSize),r=[];for(let i=s;i<=a;i+=1)r.push(this.chunkCache.get(i,i));for(let i=0;i<r.length;i+=1){const[s,a]=await r[i];yield*this.filterChunkData(t,e,s,a)}}async getChunk(t){let e=this.urlTemplate.replace(/\{Chunk\}/gi,t);this.baseUrl&&(e=a.resolve(this.baseUrl,e));return[t,await h(e,this.readFile)]}*filterChunkData(t,e,s,a){const r=s*this.chunkSize,i=Math.max(0,t-r),n=Math.min(e-r,this.chunkSize-1);for(let o=i;o<=n;o+=1)yield[o+r,a[o]]}}function f(){return this._uniqueID}function d(){return this._parent}function g(){return this.get("subfeatures")}const m=class{constructor(t){let{baseUrl:e,urlTemplate:s,readFile:a,cacheSize:r=10}=t;if(this.baseUrl=e,this.urlTemplates={root:s},this.readFile=a,!this.readFile)throw new Error('must provide a "readFile" function argument');this.dataRootCache=new(o())({cache:new(i())({maxSize:r}),fill:this.fetchDataRoot.bind(this)})}makeNCList(){return new c({readFile:this.readFile})}loadNCList(t,e,s){t.nclist.importExisting(e.intervals.nclist,t.attrs,s,e.intervals.urlTemplate,e.intervals.lazyClass)}getDataRoot(t){return this.dataRootCache.get(t,t)}fetchDataRoot(t){const e=a.resolve(this.baseUrl,this.urlTemplates.root.replace(/{\s*refseq\s*}/g,t));return h(e,this.readFile).then((t=>this.parseTrackInfo(t,e)))}parseTrackInfo(t,e){const s={nclist:this.makeNCList(),stats:{featureCount:t.featureCount||0}};t.intervals&&(s.attrs=new l(t.intervals.classes),this.loadNCList(s,t,e));const{histograms:a}=t;if(a&&a.meta){for(let t=0;t<a.meta.length;t+=1)a.meta[t].lazyArray=new u({...a.meta[t].arrayParams,readFile:this.readFile},e);s._histograms=a}return s._histograms&&Object.keys(s._histograms).forEach((t=>{s._histograms[t].forEach((t=>{Object.keys(t).forEach((e=>{"string"===typeof t[e]&&String(Number(t[e]))===t[e]&&(t[e]=Number(t[e]))}))}))})),s}async getRegionStats(t){return(await this.getDataRoot(t.ref)).stats}async getRegionFeatureDensities(t){let{refName:e,start:s,end:a,numBins:r,basesPerBin:i}=t;const n=await this.getDataRoot(e);if(r)i=(a-s)/r;else{if(!i)throw new TypeError("numBins or basesPerBin arg required for getRegionFeatureDensities");r=Math.ceil((a-s)/i)}const o=(n._histograms.stats||[]).find((t=>t.basesPerBin>=i));let h=n._histograms.meta[0];for(let l=0;l<n._histograms.meta.length;l+=1)i>=n._histograms.meta[l].basesPerBin&&(h=n._histograms.meta[l]);let c=i/h.basesPerBin;if(c>.9&&Math.abs(c-Math.round(c))<1e-4){const t=Math.floor(s/h.basesPerBin);c=Math.round(c);const e=[];for(let s=0;s<r;s+=1)e[s]=0;for await(const[s,a]of h.lazyArray.range(t,t+c*r-1))e[Math.floor((s-t)/c)]+=a;return{bins:e,stats:o}}return{bins:await n.nclist.histogram(s,a,r),stats:o}}getFeatures(t){try{var e=this;let{refName:s,start:a,end:r}=t;return async function*(){const t=await e.getDataRoot(s),i=t.attrs&&t.attrs.accessors();for await(const[n,o]of t.nclist.iterate(a,r)){if(!n.decorated){const t=o.join(",");e.decorateFeature(i,n,"".concat(s,",").concat(t))}yield n}}()}catch(s){return Promise.reject(s)}}decorateFeature(t,e,s,a){e.get=t.get,e.tags=t.tags,e._uniqueID=s,e.id=f,e._parent=a,e.parent=d,e.children=g,(e.get("subfeatures")||[]).forEach(((a,r)=>{this.decorateFeature(t,a,"".concat(s,"-").concat(r),e)})),e.decorated=!0}};var b=s(48591),p=s(10718),w=s(91775),k=s(54856);const y={refName:"seq_id"},F={seq_id:"refName"};class C{constructor(t,e,s){this.ncFeature=t,this.uniqueId=s||t.id(),this.parentHandle=e}set(){throw new Error("not implemented")}jb2TagToJb1Tag(t){return(y[t]||t).toLowerCase()}jb1TagToJb2Tag(t){const e=t.toLowerCase();return F[e]||e}get(t){const e=this.ncFeature.get(this.jb2TagToJb1Tag(t));return e&&"subfeatures"===t?e.map((t=>new C(t,this))):e}tags(){return this.ncFeature.tags().map((t=>this.jb1TagToJb2Tag(t)))}id(){return this.uniqueId}parent(){return this.parentHandle}children(){return this.get("subfeatures")}toJSON(){const t={uniqueId:this.id()};return this.ncFeature.tags().forEach((e=>{const s=this.jb1TagToJb2Tag(e),a=this.ncFeature.get(e);"subfeatures"===s?t.subfeatures=(a||[]).map((t=>new C(t,this).toJSON())):t[s]=a})),t}}class v extends b.BaseFeatureDataAdapter{constructor(t,e,s){super(t,e,s);const a=this.getConf("refNames"),r=this.getConf("rootUrlTemplate");this.configRefNames=a,this.nclist=new m({baseUrl:"",urlTemplate:r.uri,readFile:t=>new k.RemoteFile(String(r.baseUri?new URL(t,r.baseUri).toString():t)).readFile()})}getFeatures(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,p.ObservableCreate)((async s=>{const{signal:a}=e;for await(const r of this.nclist.getFeatures(t,e))(0,w.checkAbortSignal)(a),s.next(this.wrapFeature(r));s.complete()}))}wrapFeature(t){return new C(t,void 0,"".concat(this.id,"-").concat(t.id()))}async hasDataForRefName(t){var e;const s=await this.nclist.getDataRoot(t);return!!(null===(e=null===s||void 0===s?void 0:s.stats)||void 0===e?void 0:e.featureCount)}async getRefNames(){return this.configRefNames||[]}freeResources(){}}},42634:()=>{}}]);
//# sourceMappingURL=8545.9541a100.chunk.js.map